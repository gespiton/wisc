Terminals which are not used

   EPLUS
   DPLUS
   EMINUS
   DMINUS
   EMULT
   EDIVIDE
   EMODULUS
   OPPOSITE


State 0 conflicts: 2 shift/reduce
State 7 conflicts: 10 shift/reduce
State 15 conflicts: 1 shift/reduce
State 25 conflicts: 2 reduce/reduce
State 28 conflicts: 2 shift/reduce, 1 reduce/reduce
State 33 conflicts: 1 shift/reduce
State 35 conflicts: 2 shift/reduce
State 54 conflicts: 2 shift/reduce
State 55 conflicts: 11 shift/reduce
State 59 conflicts: 13 shift/reduce
State 62 conflicts: 2 shift/reduce
State 65 conflicts: 1 shift/reduce
State 68 conflicts: 1 shift/reduce
State 73 conflicts: 11 shift/reduce
State 76 conflicts: 1 shift/reduce
State 78 conflicts: 1 shift/reduce, 1 reduce/reduce
State 86 conflicts: 1 shift/reduce
State 94 conflicts: 1 shift/reduce
State 95 conflicts: 2 shift/reduce
State 99 conflicts: 11 shift/reduce
State 115 conflicts: 5 shift/reduce
State 117 conflicts: 1 shift/reduce
State 123 conflicts: 13 shift/reduce
State 124 conflicts: 10 shift/reduce
State 125 conflicts: 1 shift/reduce
State 128 conflicts: 1 shift/reduce
State 132 conflicts: 1 shift/reduce
State 137 conflicts: 1 shift/reduce
State 144 conflicts: 39 reduce/reduce
State 145 conflicts: 2 shift/reduce, 1 reduce/reduce
State 148 conflicts: 1 shift/reduce, 1 reduce/reduce
State 151 conflicts: 2 shift/reduce, 10 reduce/reduce
State 153 conflicts: 1 shift/reduce, 10 reduce/reduce
State 168 conflicts: 4 shift/reduce
State 169 conflicts: 5 shift/reduce, 31 reduce/reduce
State 173 conflicts: 1 shift/reduce
State 174 conflicts: 1 shift/reduce
State 181 conflicts: 5 shift/reduce
State 187 conflicts: 13 shift/reduce
State 189 conflicts: 5 shift/reduce
State 190 conflicts: 1 shift/reduce
State 197 conflicts: 2 shift/reduce
State 199 conflicts: 5 shift/reduce
State 201 conflicts: 5 shift/reduce
State 225 conflicts: 2 shift/reduce
State 230 conflicts: 3 shift/reduce
State 239 conflicts: 1 shift/reduce, 1 reduce/reduce
State 244 conflicts: 1 shift/reduce
State 245 conflicts: 4 shift/reduce
State 248 conflicts: 5 shift/reduce
State 253 conflicts: 1 shift/reduce
State 261 conflicts: 1 shift/reduce
State 262 conflicts: 5 shift/reduce
State 265 conflicts: 1 shift/reduce


Grammar

    0 $accept: program $end

    1 endls: endls ENDL
    2      | ENDL

    3 endlsn: /* empty */
    4       | endls

    5 endc: SEMICOLON
    6     | endls

    7 list: COMMA
    8     | list endls

    9 lists: /* empty */
   10      | list
   11      | endls

   12 name: NAME

   13 program: /* empty */
   14        | init
   15        | stats

   16 arrayType: defineType BRACKET

   17 arrayExpr: LBRACKET exprList RBRACKET

   18 dictType: LBRACE defineType RBRACE

   19 dictExpr: LBRACE dictContext RBRACE

   20 dictContext: /* empty */
   21            | dictContext lists dictList
   22            | dictList
   23            | endls dictContext
   24            | dictContext endls

   25 dictList: name expr

   26 expr: expr AND expr
   27     | expr OR expr
   28     | expr EQ expr
   29     | expr NE expr
   30     | expr GT expr
   31     | expr GE expr
   32     | expr LT expr
   33     | expr LE expr
   34     | expr PLUS expr
   35     | expr MINUS expr
   36     | expr MULT expr
   37     | expr DIVIDE expr
   38     | expr MODULUS expr
   39     | RPAREN expr LPAREN
   40     | STRING
   41     | VALUE_VOID
   42     | VALUE_BOOLEAN
   43     | INT
   44     | NUMBER
   45     | defineIden
   46     | funcExpr
   47     | arrayExpr
   48     | dictExpr

   49 exprList: /* empty */
   50         | exprList lists expr
   51         | expr
   52         | endls exprList
   53         | exprList endls

   54 @1: /* empty */

   55 @2: /* empty */

   56 defineFor: FOR LPAREN paramList @1 SEMICOLON expr SEMICOLON iteration RPAREN @2 subSpace

   57 @3: /* empty */

   58 defineFunc: defineType name funcHeaderV @3 subSpace

   59 @4: /* empty */

   60 funcExpr: funcHeaderE @4 subSpace

   61 funcHeaderV: LPAREN paramList RPAREN

   62 @5: /* empty */

   63 funcHeaderE: LPAREN @5 paramList RPAREN COLON defineType

   64 funcType: defineType COLON LPAREN typeList RPAREN

   65 defineIden: name
   66           | idenFunc
   67           | idenBracket

   68 idenFunc: defineIden LPAREN exprList RPAREN
   69         | defineIden LPAREN RPAREN

   70 idenBracket: defineIden LBRACKET expr RBRACKET

   71 defineIf: ifPart
   72         | ifPart elseIfParts
   73         | ifPart endlsn elsePart
   74         | ifPart endlsn elseIfParts endlsn elsePart

   75 @6: /* empty */

   76 ifPart: IF LPAREN expr RPAREN @6 subSpace

   77 elseIfParts: elseIfParts endlsn elseIfPart
   78            | elseIfPart

   79 @7: /* empty */

   80 elseIfPart: ELSE IF LPAREN expr RPAREN @7 subSpace

   81 @8: /* empty */

   82 elsePart: ELSE @8 subSpace

   83 init: DINIT endls initContext DEND

   84 initContext: /* empty */
   85            | initOperator

   86 initOperator: OPERATOR LBRACE initOperatorContexts RBRACE endls

   87 initOperatorContexts: initOperatorContexts initOperatorContext
   88                     | initOperatorContext

   89 initOperatorContext: endls
   90                    | defineType operator defineType ASSIGN name endls

   91 assignment: /* empty */
   92           | defineIden ASSIGN expr

   93 iteration: assignment
   94          | idenFunc

   95 operator: PLUS
   96         | MINUS
   97         | MULT
   98         | DIVIDE
   99         | MODULUS
  100         | EQ
  101         | NE
  102         | GT
  103         | GE
  104         | LT
  105         | LE

  106 defineParam: defineType name
  107            | defineType name ASSIGN expr

  108 paramListP: paramListP list defineParam
  109           | defineParam

  110 paramList: /* empty */
  111          | paramListP
  112          | endls paramList
  113          | paramList endls

  114 subSpace: LBRACE endlsn stats RBRACE
  115         | stat
  116         | LBRACE endlsn stat endlsn RBRACE
  117         | endls subSpace

  118 controlSpace: RETURN expr
  119             | RETURN
  120             | BREAK
  121             | CONTINUE

  122 stats: stats stat endc
  123      | stat endc

  124 stat: endc
  125     | iteration
  126     | controlSpace
  127     | defineStat
  128     | defineIf
  129     | defineWhile
  130     | defineFor
  131     | defineSwitch

  132 defineStat: defineFunc
  133           | defineVariale

  134 @9: /* empty */

  135 defineSwitch: SWITCH LPAREN expr RPAREN @9 switchSpace

  136 switchSpace: LBRACE switchStats RBRACE
  137            | endls switchSpace

  138 switchStats: switchStats switchStat
  139            | switchStat

  140 switchStat: /* empty */
  141           | endls

  142 @10: /* empty */

  143 switchStat: CASE LPAREN expr RPAREN @10 subSpace

  144 @11: /* empty */

  145 switchStat: DEFAULT @11 subSpace

  146 defineType: name
  147           | funcType
  148           | arrayType
  149           | dictType
  150           | LPAREN typeListM RPAREN

  151 typeListM: typeListM SOR defineType
  152          | defineType

  153 typeListP: typeListP list defineType
  154          | defineType

  155 typeList: /* empty */
  156         | typeListP

  157 defineVariale: paramListP
  158              | CONST paramListP

  159 @12: /* empty */

  160 defineWhile: WHILE LPAREN expr RPAREN @12 subSpace


Terminals, with rules where they appear

$end (0) 0
error (256)
OR (258) 27
AND (259) 26
NE (260) 29 101
EQ (261) 28 100
GE (262) 31 103
GT (263) 30 102
LE (264) 33 105
LT (265) 32 104
MINUS (266) 35 96
PLUS (267) 34 95
MODULUS (268) 38 99
DIVIDE (269) 37 98
MULT (270) 36 97
NAME (271) 12
ENDL (272) 1 2
INT (273) 43
NUMBER (274) 44
STRING (275) 40
VALUE_BOOLEAN (276) 42
VALUE_VOID (277) 41
SEMICOLON (278) 5 56
COLON (279) 63 64
ASSIGN (280) 90 92 107
RPAREN (281) 39 56 61 63 64 68 69 76 80 135 143 150 160
LPAREN (282) 39 56 61 63 64 68 69 76 80 135 143 150 160
RBRACE (283) 18 19 86 114 116 136
LBRACE (284) 18 19 86 114 116 136
COMMA (285) 7
BRACKET (286) 16
RBRACKET (287) 17 70
LBRACKET (288) 17 70
DINIT (289) 83
DEND (290) 83
RETURN (291) 118 119
IF (292) 76 80
ELSE (293) 80 82
FOR (294) 56
WHILE (295) 160
SWITCH (296) 135
CASE (297) 143
DEFAULT (298) 145
BREAK (299) 120
CONTINUE (300) 121
OPERATOR (301) 86
CONST (302) 158
SOR (303) 151
EPLUS (304)
DPLUS (305)
EMINUS (306)
DMINUS (307)
EMULT (308)
EDIVIDE (309)
EMODULUS (310)
OPPOSITE (311)


Nonterminals, with rules where they appear

$accept (57)
    on left: 0
endls (58)
    on left: 1 2, on right: 1 4 6 8 11 23 24 52 53 83 86 89 90 112
    113 117 137 141
endlsn (59)
    on left: 3 4, on right: 73 74 77 114 116
endc (60)
    on left: 5 6, on right: 122 123 124
list (61)
    on left: 7 8, on right: 8 10 108 153
lists (62)
    on left: 9 10 11, on right: 21 50
name (63)
    on left: 12, on right: 25 58 65 90 106 107 146
program (64)
    on left: 13 14 15, on right: 0
arrayType (65)
    on left: 16, on right: 148
arrayExpr (66)
    on left: 17, on right: 47
dictType (67)
    on left: 18, on right: 149
dictExpr (68)
    on left: 19, on right: 48
dictContext (69)
    on left: 20 21 22 23 24, on right: 19 21 23 24
dictList (70)
    on left: 25, on right: 21 22
expr (71)
    on left: 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43
    44 45 46 47 48, on right: 25 26 27 28 29 30 31 32 33 34 35 36 37
    38 39 50 51 56 70 76 80 92 107 118 135 143 160
exprList (72)
    on left: 49 50 51 52 53, on right: 17 50 52 53 68
defineFor (73)
    on left: 56, on right: 130
@1 (74)
    on left: 54, on right: 56
@2 (75)
    on left: 55, on right: 56
defineFunc (76)
    on left: 58, on right: 132
@3 (77)
    on left: 57, on right: 58
funcExpr (78)
    on left: 60, on right: 46
@4 (79)
    on left: 59, on right: 60
funcHeaderV (80)
    on left: 61, on right: 58
funcHeaderE (81)
    on left: 63, on right: 60
@5 (82)
    on left: 62, on right: 63
funcType (83)
    on left: 64, on right: 147
defineIden (84)
    on left: 65 66 67, on right: 45 68 69 70 92
idenFunc (85)
    on left: 68 69, on right: 66 94
idenBracket (86)
    on left: 70, on right: 67
defineIf (87)
    on left: 71 72 73 74, on right: 128
ifPart (88)
    on left: 76, on right: 71 72 73 74
@6 (89)
    on left: 75, on right: 76
elseIfParts (90)
    on left: 77 78, on right: 72 74 77
elseIfPart (91)
    on left: 80, on right: 77 78
@7 (92)
    on left: 79, on right: 80
elsePart (93)
    on left: 82, on right: 73 74
@8 (94)
    on left: 81, on right: 82
init (95)
    on left: 83, on right: 14
initContext (96)
    on left: 84 85, on right: 83
initOperator (97)
    on left: 86, on right: 85
initOperatorContexts (98)
    on left: 87 88, on right: 86 87
initOperatorContext (99)
    on left: 89 90, on right: 87 88
assignment (100)
    on left: 91 92, on right: 93
iteration (101)
    on left: 93 94, on right: 56 125
operator (102)
    on left: 95 96 97 98 99 100 101 102 103 104 105,
    on right: 90
defineParam (103)
    on left: 106 107, on right: 108 109
paramListP (104)
    on left: 108 109, on right: 108 111 157 158
paramList (105)
    on left: 110 111 112 113, on right: 56 61 63 112 113
subSpace (106)
    on left: 114 115 116 117, on right: 56 58 60 76 80 82 117 143 145
    160
controlSpace (107)
    on left: 118 119 120 121, on right: 126
stats (108)
    on left: 122 123, on right: 15 114 122
stat (109)
    on left: 124 125 126 127 128 129 130 131, on right: 115 116 122
    123
defineStat (110)
    on left: 132 133, on right: 127
defineSwitch (111)
    on left: 135, on right: 131
@9 (112)
    on left: 134, on right: 135
switchSpace (113)
    on left: 136 137, on right: 135 137
switchStats (114)
    on left: 138 139, on right: 136 138
switchStat (115)
    on left: 140 141 143 145, on right: 138 139
@10 (116)
    on left: 142, on right: 143
@11 (117)
    on left: 144, on right: 145
defineType (118)
    on left: 146 147 148 149 150, on right: 16 18 58 63 64 90 106 107
    151 152 153 154
typeListM (119)
    on left: 151 152, on right: 150 151
typeListP (120)
    on left: 153 154, on right: 153 156
typeList (121)
    on left: 155 156, on right: 64
defineVariale (122)
    on left: 157 158, on right: 133
defineWhile (123)
    on left: 160, on right: 129
@12 (124)
    on left: 159, on right: 160


state 0

    0 $accept: . program $end

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    LPAREN     shift, and go to state 4
    LBRACE     shift, and go to state 5
    DINIT      shift, and go to state 6
    RETURN     shift, and go to state 7
    IF         shift, and go to state 8
    FOR        shift, and go to state 9
    WHILE      shift, and go to state 10
    SWITCH     shift, and go to state 11
    BREAK      shift, and go to state 12
    CONTINUE   shift, and go to state 13
    CONST      shift, and go to state 14

    ENDL       [reduce using rule 91 (assignment)]
    SEMICOLON  [reduce using rule 91 (assignment)]
    $default   reduce using rule 13 (program)

    endls          go to state 15
    endc           go to state 16
    name           go to state 17
    program        go to state 18
    arrayType      go to state 19
    dictType       go to state 20
    defineFor      go to state 21
    defineFunc     go to state 22
    funcType       go to state 23
    defineIden     go to state 24
    idenFunc       go to state 25
    idenBracket    go to state 26
    defineIf       go to state 27
    ifPart         go to state 28
    init           go to state 29
    assignment     go to state 30
    iteration      go to state 31
    defineParam    go to state 32
    paramListP     go to state 33
    controlSpace   go to state 34
    stats          go to state 35
    stat           go to state 36
    defineStat     go to state 37
    defineSwitch   go to state 38
    defineType     go to state 39
    defineVariale  go to state 40
    defineWhile    go to state 41


state 1

   12 name: NAME .

    $default  reduce using rule 12 (name)


state 2

    2 endls: ENDL .

    $default  reduce using rule 2 (endls)


state 3

    5 endc: SEMICOLON .

    $default  reduce using rule 5 (endc)


state 4

  150 defineType: LPAREN . typeListM RPAREN

    NAME    shift, and go to state 1
    LPAREN  shift, and go to state 4
    LBRACE  shift, and go to state 5

    name        go to state 42
    arrayType   go to state 19
    dictType    go to state 20
    funcType    go to state 23
    defineType  go to state 43
    typeListM   go to state 44


state 5

   18 dictType: LBRACE . defineType RBRACE

    NAME    shift, and go to state 1
    LPAREN  shift, and go to state 4
    LBRACE  shift, and go to state 5

    name        go to state 42
    arrayType   go to state 19
    dictType    go to state 20
    funcType    go to state 23
    defineType  go to state 45


state 6

   83 init: DINIT . endls initContext DEND

    ENDL  shift, and go to state 2

    endls  go to state 46


state 7

  118 controlSpace: RETURN . expr
  119             | RETURN .

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    NAME           [reduce using rule 119 (controlSpace)]
    INT            [reduce using rule 119 (controlSpace)]
    NUMBER         [reduce using rule 119 (controlSpace)]
    STRING         [reduce using rule 119 (controlSpace)]
    VALUE_BOOLEAN  [reduce using rule 119 (controlSpace)]
    VALUE_VOID     [reduce using rule 119 (controlSpace)]
    RPAREN         [reduce using rule 119 (controlSpace)]
    LPAREN         [reduce using rule 119 (controlSpace)]
    LBRACE         [reduce using rule 119 (controlSpace)]
    LBRACKET       [reduce using rule 119 (controlSpace)]
    $default       reduce using rule 119 (controlSpace)

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 59
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 8

   76 ifPart: IF . LPAREN expr RPAREN @6 subSpace

    LPAREN  shift, and go to state 64


state 9

   56 defineFor: FOR . LPAREN paramList @1 SEMICOLON expr SEMICOLON iteration RPAREN @2 subSpace

    LPAREN  shift, and go to state 65


state 10

  160 defineWhile: WHILE . LPAREN expr RPAREN @12 subSpace

    LPAREN  shift, and go to state 66


state 11

  135 defineSwitch: SWITCH . LPAREN expr RPAREN @9 switchSpace

    LPAREN  shift, and go to state 67


state 12

  120 controlSpace: BREAK .

    $default  reduce using rule 120 (controlSpace)


state 13

  121 controlSpace: CONTINUE .

    $default  reduce using rule 121 (controlSpace)


state 14

  158 defineVariale: CONST . paramListP

    NAME    shift, and go to state 1
    LPAREN  shift, and go to state 4
    LBRACE  shift, and go to state 5

    name         go to state 42
    arrayType    go to state 19
    dictType     go to state 20
    funcType     go to state 23
    defineParam  go to state 32
    paramListP   go to state 68
    defineType   go to state 69


state 15

    1 endls: endls . ENDL
    6 endc: endls .

    ENDL  shift, and go to state 70

    ENDL      [reduce using rule 6 (endc)]
    $default  reduce using rule 6 (endc)


state 16

  124 stat: endc .

    $default  reduce using rule 124 (stat)


state 17

   65 defineIden: name .
  146 defineType: name .

    NAME      reduce using rule 146 (defineType)
    COLON     reduce using rule 146 (defineType)
    BRACKET   reduce using rule 146 (defineType)
    $default  reduce using rule 65 (defineIden)


state 18

    0 $accept: program . $end

    $end  shift, and go to state 71


state 19

  148 defineType: arrayType .

    $default  reduce using rule 148 (defineType)


state 20

  149 defineType: dictType .

    $default  reduce using rule 149 (defineType)


state 21

  130 stat: defineFor .

    $default  reduce using rule 130 (stat)


state 22

  132 defineStat: defineFunc .

    $default  reduce using rule 132 (defineStat)


state 23

  147 defineType: funcType .

    $default  reduce using rule 147 (defineType)


state 24

   68 idenFunc: defineIden . LPAREN exprList RPAREN
   69         | defineIden . LPAREN RPAREN
   70 idenBracket: defineIden . LBRACKET expr RBRACKET
   92 assignment: defineIden . ASSIGN expr

    ASSIGN    shift, and go to state 72
    LPAREN    shift, and go to state 73
    LBRACKET  shift, and go to state 74


state 25

   66 defineIden: idenFunc .
   94 iteration: idenFunc .

    ASSIGN    reduce using rule 66 (defineIden)
    LPAREN    reduce using rule 66 (defineIden)
    LPAREN    [reduce using rule 94 (iteration)]
    LBRACKET  reduce using rule 66 (defineIden)
    LBRACKET  [reduce using rule 94 (iteration)]
    $default  reduce using rule 94 (iteration)


state 26

   67 defineIden: idenBracket .

    $default  reduce using rule 67 (defineIden)


state 27

  128 stat: defineIf .

    $default  reduce using rule 128 (stat)


state 28

   71 defineIf: ifPart .
   72         | ifPart . elseIfParts
   73         | ifPart . endlsn elsePart
   74         | ifPart . endlsn elseIfParts endlsn elsePart

    ENDL  shift, and go to state 2
    ELSE  shift, and go to state 75

    ENDL      [reduce using rule 71 (defineIf)]
    ELSE      [reduce using rule 3 (endlsn)]
    ELSE      [reduce using rule 71 (defineIf)]
    $default  reduce using rule 71 (defineIf)

    endls        go to state 76
    endlsn       go to state 77
    elseIfParts  go to state 78
    elseIfPart   go to state 79


state 29

   14 program: init .

    $default  reduce using rule 14 (program)


state 30

   93 iteration: assignment .

    $default  reduce using rule 93 (iteration)


state 31

  125 stat: iteration .

    $default  reduce using rule 125 (stat)


state 32

  109 paramListP: defineParam .

    $default  reduce using rule 109 (paramListP)


state 33

  108 paramListP: paramListP . list defineParam
  157 defineVariale: paramListP .

    COMMA  shift, and go to state 80

    COMMA     [reduce using rule 157 (defineVariale)]
    $default  reduce using rule 157 (defineVariale)

    list  go to state 81


state 34

  126 stat: controlSpace .

    $default  reduce using rule 126 (stat)


state 35

   15 program: stats .
  122 stats: stats . stat endc

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    LPAREN     shift, and go to state 4
    LBRACE     shift, and go to state 5
    RETURN     shift, and go to state 7
    IF         shift, and go to state 8
    FOR        shift, and go to state 9
    WHILE      shift, and go to state 10
    SWITCH     shift, and go to state 11
    BREAK      shift, and go to state 12
    CONTINUE   shift, and go to state 13
    CONST      shift, and go to state 14

    ENDL       [reduce using rule 91 (assignment)]
    SEMICOLON  [reduce using rule 91 (assignment)]
    $default   reduce using rule 15 (program)

    endls          go to state 15
    endc           go to state 16
    name           go to state 17
    arrayType      go to state 19
    dictType       go to state 20
    defineFor      go to state 21
    defineFunc     go to state 22
    funcType       go to state 23
    defineIden     go to state 24
    idenFunc       go to state 25
    idenBracket    go to state 26
    defineIf       go to state 27
    ifPart         go to state 28
    assignment     go to state 30
    iteration      go to state 31
    defineParam    go to state 32
    paramListP     go to state 33
    controlSpace   go to state 34
    stat           go to state 82
    defineStat     go to state 37
    defineSwitch   go to state 38
    defineType     go to state 39
    defineVariale  go to state 40
    defineWhile    go to state 41


state 36

  123 stats: stat . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 15
    endc   go to state 83


state 37

  127 stat: defineStat .

    $default  reduce using rule 127 (stat)


state 38

  131 stat: defineSwitch .

    $default  reduce using rule 131 (stat)


state 39

   16 arrayType: defineType . BRACKET
   58 defineFunc: defineType . name funcHeaderV @3 subSpace
   64 funcType: defineType . COLON LPAREN typeList RPAREN
  106 defineParam: defineType . name
  107            | defineType . name ASSIGN expr

    NAME     shift, and go to state 1
    COLON    shift, and go to state 84
    BRACKET  shift, and go to state 85

    name  go to state 86


state 40

  133 defineStat: defineVariale .

    $default  reduce using rule 133 (defineStat)


state 41

  129 stat: defineWhile .

    $default  reduce using rule 129 (stat)


state 42

  146 defineType: name .

    $default  reduce using rule 146 (defineType)


state 43

   16 arrayType: defineType . BRACKET
   64 funcType: defineType . COLON LPAREN typeList RPAREN
  152 typeListM: defineType .

    COLON    shift, and go to state 84
    BRACKET  shift, and go to state 85

    $default  reduce using rule 152 (typeListM)


state 44

  150 defineType: LPAREN typeListM . RPAREN
  151 typeListM: typeListM . SOR defineType

    RPAREN  shift, and go to state 87
    SOR     shift, and go to state 88


state 45

   16 arrayType: defineType . BRACKET
   18 dictType: LBRACE defineType . RBRACE
   64 funcType: defineType . COLON LPAREN typeList RPAREN

    COLON    shift, and go to state 84
    RBRACE   shift, and go to state 89
    BRACKET  shift, and go to state 85


state 46

    1 endls: endls . ENDL
   83 init: DINIT endls . initContext DEND

    ENDL      shift, and go to state 70
    OPERATOR  shift, and go to state 90

    $default  reduce using rule 84 (initContext)

    initContext   go to state 91
    initOperator  go to state 92


state 47

   43 expr: INT .

    $default  reduce using rule 43 (expr)


state 48

   44 expr: NUMBER .

    $default  reduce using rule 44 (expr)


state 49

   40 expr: STRING .

    $default  reduce using rule 40 (expr)


state 50

   42 expr: VALUE_BOOLEAN .

    $default  reduce using rule 42 (expr)


state 51

   41 expr: VALUE_VOID .

    $default  reduce using rule 41 (expr)


state 52

   39 expr: RPAREN . expr LPAREN

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 93
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 53

   63 funcHeaderE: LPAREN . @5 paramList RPAREN COLON defineType

    $default  reduce using rule 62 (@5)

    @5  go to state 94


state 54

   19 dictExpr: LBRACE . dictContext RBRACE

    NAME  shift, and go to state 1
    ENDL  shift, and go to state 2

    NAME      [reduce using rule 20 (dictContext)]
    ENDL      [reduce using rule 20 (dictContext)]
    $default  reduce using rule 20 (dictContext)

    endls        go to state 95
    name         go to state 96
    dictContext  go to state 97
    dictList     go to state 98


state 55

   17 arrayExpr: LBRACKET . exprList RBRACKET

    NAME           shift, and go to state 1
    ENDL           shift, and go to state 2
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    NAME           [reduce using rule 49 (exprList)]
    ENDL           [reduce using rule 49 (exprList)]
    INT            [reduce using rule 49 (exprList)]
    NUMBER         [reduce using rule 49 (exprList)]
    STRING         [reduce using rule 49 (exprList)]
    VALUE_BOOLEAN  [reduce using rule 49 (exprList)]
    VALUE_VOID     [reduce using rule 49 (exprList)]
    RPAREN         [reduce using rule 49 (exprList)]
    LPAREN         [reduce using rule 49 (exprList)]
    LBRACE         [reduce using rule 49 (exprList)]
    LBRACKET       [reduce using rule 49 (exprList)]
    $default       reduce using rule 49 (exprList)

    endls        go to state 99
    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 100
    exprList     go to state 101
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 56

   65 defineIden: name .

    $default  reduce using rule 65 (defineIden)


state 57

   47 expr: arrayExpr .

    $default  reduce using rule 47 (expr)


state 58

   48 expr: dictExpr .

    $default  reduce using rule 48 (expr)


state 59

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr
  118 controlSpace: RETURN expr .

    OR       shift, and go to state 102
    AND      shift, and go to state 103
    NE       shift, and go to state 104
    EQ       shift, and go to state 105
    GE       shift, and go to state 106
    GT       shift, and go to state 107
    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114

    OR        [reduce using rule 118 (controlSpace)]
    AND       [reduce using rule 118 (controlSpace)]
    NE        [reduce using rule 118 (controlSpace)]
    EQ        [reduce using rule 118 (controlSpace)]
    GE        [reduce using rule 118 (controlSpace)]
    GT        [reduce using rule 118 (controlSpace)]
    LE        [reduce using rule 118 (controlSpace)]
    LT        [reduce using rule 118 (controlSpace)]
    MINUS     [reduce using rule 118 (controlSpace)]
    PLUS      [reduce using rule 118 (controlSpace)]
    MODULUS   [reduce using rule 118 (controlSpace)]
    DIVIDE    [reduce using rule 118 (controlSpace)]
    MULT      [reduce using rule 118 (controlSpace)]
    $default  reduce using rule 118 (controlSpace)


state 60

   46 expr: funcExpr .

    $default  reduce using rule 46 (expr)


state 61

   60 funcExpr: funcHeaderE . @4 subSpace

    $default  reduce using rule 59 (@4)

    @4  go to state 115


state 62

   45 expr: defineIden .
   68 idenFunc: defineIden . LPAREN exprList RPAREN
   69         | defineIden . LPAREN RPAREN
   70 idenBracket: defineIden . LBRACKET expr RBRACKET

    LPAREN    shift, and go to state 73
    LBRACKET  shift, and go to state 74

    LPAREN    [reduce using rule 45 (expr)]
    LBRACKET  [reduce using rule 45 (expr)]
    $default  reduce using rule 45 (expr)


state 63

   66 defineIden: idenFunc .

    $default  reduce using rule 66 (defineIden)


state 64

   76 ifPart: IF LPAREN . expr RPAREN @6 subSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 116
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 65

   56 defineFor: FOR LPAREN . paramList @1 SEMICOLON expr SEMICOLON iteration RPAREN @2 subSpace

    NAME    shift, and go to state 1
    ENDL    shift, and go to state 2
    LPAREN  shift, and go to state 4
    LBRACE  shift, and go to state 5

    ENDL      [reduce using rule 110 (paramList)]
    $default  reduce using rule 110 (paramList)

    endls        go to state 117
    name         go to state 42
    arrayType    go to state 19
    dictType     go to state 20
    funcType     go to state 23
    defineParam  go to state 32
    paramListP   go to state 118
    paramList    go to state 119
    defineType   go to state 69


state 66

  160 defineWhile: WHILE LPAREN . expr RPAREN @12 subSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 120
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 67

  135 defineSwitch: SWITCH LPAREN . expr RPAREN @9 switchSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 121
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 68

  108 paramListP: paramListP . list defineParam
  158 defineVariale: CONST paramListP .

    COMMA  shift, and go to state 80

    COMMA     [reduce using rule 158 (defineVariale)]
    $default  reduce using rule 158 (defineVariale)

    list  go to state 81


state 69

   16 arrayType: defineType . BRACKET
   64 funcType: defineType . COLON LPAREN typeList RPAREN
  106 defineParam: defineType . name
  107            | defineType . name ASSIGN expr

    NAME     shift, and go to state 1
    COLON    shift, and go to state 84
    BRACKET  shift, and go to state 85

    name  go to state 122


state 70

    1 endls: endls ENDL .

    $default  reduce using rule 1 (endls)


state 71

    0 $accept: program $end .

    $default  accept


state 72

   92 assignment: defineIden ASSIGN . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 123
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 73

   68 idenFunc: defineIden LPAREN . exprList RPAREN
   69         | defineIden LPAREN . RPAREN

    NAME           shift, and go to state 1
    ENDL           shift, and go to state 2
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 124
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    NAME           [reduce using rule 49 (exprList)]
    ENDL           [reduce using rule 49 (exprList)]
    INT            [reduce using rule 49 (exprList)]
    NUMBER         [reduce using rule 49 (exprList)]
    STRING         [reduce using rule 49 (exprList)]
    VALUE_BOOLEAN  [reduce using rule 49 (exprList)]
    VALUE_VOID     [reduce using rule 49 (exprList)]
    RPAREN         [reduce using rule 49 (exprList)]
    LPAREN         [reduce using rule 49 (exprList)]
    LBRACE         [reduce using rule 49 (exprList)]
    LBRACKET       [reduce using rule 49 (exprList)]
    $default       reduce using rule 49 (exprList)

    endls        go to state 99
    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 100
    exprList     go to state 125
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 74

   70 idenBracket: defineIden LBRACKET . expr RBRACKET

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 126
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 75

   80 elseIfPart: ELSE . IF LPAREN expr RPAREN @7 subSpace

    IF  shift, and go to state 127


state 76

    1 endls: endls . ENDL
    4 endlsn: endls .

    ENDL  shift, and go to state 70

    ENDL      [reduce using rule 4 (endlsn)]
    $default  reduce using rule 4 (endlsn)


state 77

   73 defineIf: ifPart endlsn . elsePart
   74         | ifPart endlsn . elseIfParts endlsn elsePart

    ELSE  shift, and go to state 128

    elseIfParts  go to state 129
    elseIfPart   go to state 79
    elsePart     go to state 130


state 78

   72 defineIf: ifPart elseIfParts .
   77 elseIfParts: elseIfParts . endlsn elseIfPart

    ENDL  shift, and go to state 2

    ENDL      [reduce using rule 72 (defineIf)]
    ELSE      reduce using rule 3 (endlsn)
    ELSE      [reduce using rule 72 (defineIf)]
    $default  reduce using rule 72 (defineIf)

    endls   go to state 76
    endlsn  go to state 131


state 79

   78 elseIfParts: elseIfPart .

    $default  reduce using rule 78 (elseIfParts)


state 80

    7 list: COMMA .

    $default  reduce using rule 7 (list)


state 81

    8 list: list . endls
  108 paramListP: paramListP list . defineParam

    NAME    shift, and go to state 1
    ENDL    shift, and go to state 2
    LPAREN  shift, and go to state 4
    LBRACE  shift, and go to state 5

    endls        go to state 132
    name         go to state 42
    arrayType    go to state 19
    dictType     go to state 20
    funcType     go to state 23
    defineParam  go to state 133
    defineType   go to state 69


state 82

  122 stats: stats stat . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 15
    endc   go to state 134


state 83

  123 stats: stat endc .

    $default  reduce using rule 123 (stats)


state 84

   64 funcType: defineType COLON . LPAREN typeList RPAREN

    LPAREN  shift, and go to state 135


state 85

   16 arrayType: defineType BRACKET .

    $default  reduce using rule 16 (arrayType)


state 86

   58 defineFunc: defineType name . funcHeaderV @3 subSpace
  106 defineParam: defineType name .
  107            | defineType name . ASSIGN expr

    ASSIGN  shift, and go to state 136
    LPAREN  shift, and go to state 137

    LPAREN    [reduce using rule 106 (defineParam)]
    $default  reduce using rule 106 (defineParam)

    funcHeaderV  go to state 138


state 87

  150 defineType: LPAREN typeListM RPAREN .

    $default  reduce using rule 150 (defineType)


state 88

  151 typeListM: typeListM SOR . defineType

    NAME    shift, and go to state 1
    LPAREN  shift, and go to state 4
    LBRACE  shift, and go to state 5

    name        go to state 42
    arrayType   go to state 19
    dictType    go to state 20
    funcType    go to state 23
    defineType  go to state 139


state 89

   18 dictType: LBRACE defineType RBRACE .

    $default  reduce using rule 18 (dictType)


state 90

   86 initOperator: OPERATOR . LBRACE initOperatorContexts RBRACE endls

    LBRACE  shift, and go to state 140


state 91

   83 init: DINIT endls initContext . DEND

    DEND  shift, and go to state 141


state 92

   85 initContext: initOperator .

    $default  reduce using rule 85 (initContext)


state 93

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr
   39     | RPAREN expr . LPAREN

    OR       shift, and go to state 102
    AND      shift, and go to state 103
    NE       shift, and go to state 104
    EQ       shift, and go to state 105
    GE       shift, and go to state 106
    GT       shift, and go to state 107
    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114
    LPAREN   shift, and go to state 142


state 94

   63 funcHeaderE: LPAREN @5 . paramList RPAREN COLON defineType

    NAME    shift, and go to state 1
    ENDL    shift, and go to state 2
    LPAREN  shift, and go to state 4
    LBRACE  shift, and go to state 5

    ENDL      [reduce using rule 110 (paramList)]
    $default  reduce using rule 110 (paramList)

    endls        go to state 117
    name         go to state 42
    arrayType    go to state 19
    dictType     go to state 20
    funcType     go to state 23
    defineParam  go to state 32
    paramListP   go to state 118
    paramList    go to state 143
    defineType   go to state 69


state 95

    1 endls: endls . ENDL
   23 dictContext: endls . dictContext

    NAME  shift, and go to state 1
    ENDL  shift, and go to state 144

    NAME      [reduce using rule 20 (dictContext)]
    ENDL      [reduce using rule 20 (dictContext)]
    $default  reduce using rule 20 (dictContext)

    endls        go to state 95
    name         go to state 96
    dictContext  go to state 145
    dictList     go to state 98


state 96

   25 dictList: name . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 146
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 97

   19 dictExpr: LBRACE dictContext . RBRACE
   21 dictContext: dictContext . lists dictList
   24            | dictContext . endls

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 147
    COMMA   shift, and go to state 80

    $default  reduce using rule 9 (lists)

    endls  go to state 148
    list   go to state 149
    lists  go to state 150


state 98

   22 dictContext: dictList .

    $default  reduce using rule 22 (dictContext)


state 99

    1 endls: endls . ENDL
   52 exprList: endls . exprList

    NAME           shift, and go to state 1
    ENDL           shift, and go to state 144
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    NAME           [reduce using rule 49 (exprList)]
    ENDL           [reduce using rule 49 (exprList)]
    INT            [reduce using rule 49 (exprList)]
    NUMBER         [reduce using rule 49 (exprList)]
    STRING         [reduce using rule 49 (exprList)]
    VALUE_BOOLEAN  [reduce using rule 49 (exprList)]
    VALUE_VOID     [reduce using rule 49 (exprList)]
    RPAREN         [reduce using rule 49 (exprList)]
    LPAREN         [reduce using rule 49 (exprList)]
    LBRACE         [reduce using rule 49 (exprList)]
    LBRACKET       [reduce using rule 49 (exprList)]
    $default       reduce using rule 49 (exprList)

    endls        go to state 99
    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 100
    exprList     go to state 151
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 100

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr
   51 exprList: expr .

    OR       shift, and go to state 102
    AND      shift, and go to state 103
    NE       shift, and go to state 104
    EQ       shift, and go to state 105
    GE       shift, and go to state 106
    GT       shift, and go to state 107
    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114

    $default  reduce using rule 51 (exprList)


state 101

   17 arrayExpr: LBRACKET exprList . RBRACKET
   50 exprList: exprList . lists expr
   53         | exprList . endls

    ENDL      shift, and go to state 2
    COMMA     shift, and go to state 80
    RBRACKET  shift, and go to state 152

    $default  reduce using rule 9 (lists)

    endls  go to state 153
    list   go to state 149
    lists  go to state 154


state 102

   27 expr: expr OR . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 155
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 103

   26 expr: expr AND . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 156
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 104

   29 expr: expr NE . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 157
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 105

   28 expr: expr EQ . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 158
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 106

   31 expr: expr GE . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 159
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 107

   30 expr: expr GT . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 160
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 108

   33 expr: expr LE . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 161
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 109

   32 expr: expr LT . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 162
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 110

   35 expr: expr MINUS . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 163
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 111

   34 expr: expr PLUS . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 164
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 112

   38 expr: expr MODULUS . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 165
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 113

   37 expr: expr DIVIDE . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 166
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 114

   36 expr: expr MULT . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 167
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 115

   60 funcExpr: funcHeaderE @4 . subSpace

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    LPAREN     shift, and go to state 4
    LBRACE     shift, and go to state 168
    RETURN     shift, and go to state 7
    IF         shift, and go to state 8
    FOR        shift, and go to state 9
    WHILE      shift, and go to state 10
    SWITCH     shift, and go to state 11
    BREAK      shift, and go to state 12
    CONTINUE   shift, and go to state 13
    CONST      shift, and go to state 14

    NAME       [reduce using rule 91 (assignment)]
    ENDL       [reduce using rule 91 (assignment)]
    SEMICOLON  [reduce using rule 91 (assignment)]
    LPAREN     [reduce using rule 91 (assignment)]
    LBRACE     [reduce using rule 91 (assignment)]
    $default   reduce using rule 91 (assignment)

    endls          go to state 169
    endc           go to state 16
    name           go to state 17
    arrayType      go to state 19
    dictType       go to state 20
    defineFor      go to state 21
    defineFunc     go to state 22
    funcType       go to state 23
    defineIden     go to state 24
    idenFunc       go to state 25
    idenBracket    go to state 26
    defineIf       go to state 27
    ifPart         go to state 28
    assignment     go to state 30
    iteration      go to state 31
    defineParam    go to state 32
    paramListP     go to state 33
    subSpace       go to state 170
    controlSpace   go to state 34
    stat           go to state 171
    defineStat     go to state 37
    defineSwitch   go to state 38
    defineType     go to state 39
    defineVariale  go to state 40
    defineWhile    go to state 41


state 116

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr
   76 ifPart: IF LPAREN expr . RPAREN @6 subSpace

    OR       shift, and go to state 102
    AND      shift, and go to state 103
    NE       shift, and go to state 104
    EQ       shift, and go to state 105
    GE       shift, and go to state 106
    GT       shift, and go to state 107
    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114
    RPAREN   shift, and go to state 172


state 117

    1 endls: endls . ENDL
  112 paramList: endls . paramList

    NAME    shift, and go to state 1
    ENDL    shift, and go to state 144
    LPAREN  shift, and go to state 4
    LBRACE  shift, and go to state 5

    ENDL      [reduce using rule 110 (paramList)]
    $default  reduce using rule 110 (paramList)

    endls        go to state 117
    name         go to state 42
    arrayType    go to state 19
    dictType     go to state 20
    funcType     go to state 23
    defineParam  go to state 32
    paramListP   go to state 118
    paramList    go to state 173
    defineType   go to state 69


state 118

  108 paramListP: paramListP . list defineParam
  111 paramList: paramListP .

    COMMA  shift, and go to state 80

    $default  reduce using rule 111 (paramList)

    list  go to state 81


state 119

   56 defineFor: FOR LPAREN paramList . @1 SEMICOLON expr SEMICOLON iteration RPAREN @2 subSpace
  113 paramList: paramList . endls

    ENDL  shift, and go to state 2

    $default  reduce using rule 54 (@1)

    endls  go to state 174
    @1     go to state 175


state 120

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr
  160 defineWhile: WHILE LPAREN expr . RPAREN @12 subSpace

    OR       shift, and go to state 102
    AND      shift, and go to state 103
    NE       shift, and go to state 104
    EQ       shift, and go to state 105
    GE       shift, and go to state 106
    GT       shift, and go to state 107
    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114
    RPAREN   shift, and go to state 176


state 121

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr
  135 defineSwitch: SWITCH LPAREN expr . RPAREN @9 switchSpace

    OR       shift, and go to state 102
    AND      shift, and go to state 103
    NE       shift, and go to state 104
    EQ       shift, and go to state 105
    GE       shift, and go to state 106
    GT       shift, and go to state 107
    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114
    RPAREN   shift, and go to state 177


state 122

  106 defineParam: defineType name .
  107            | defineType name . ASSIGN expr

    ASSIGN  shift, and go to state 136

    $default  reduce using rule 106 (defineParam)


state 123

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr
   92 assignment: defineIden ASSIGN expr .

    OR       shift, and go to state 102
    AND      shift, and go to state 103
    NE       shift, and go to state 104
    EQ       shift, and go to state 105
    GE       shift, and go to state 106
    GT       shift, and go to state 107
    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114

    OR        [reduce using rule 92 (assignment)]
    AND       [reduce using rule 92 (assignment)]
    NE        [reduce using rule 92 (assignment)]
    EQ        [reduce using rule 92 (assignment)]
    GE        [reduce using rule 92 (assignment)]
    GT        [reduce using rule 92 (assignment)]
    LE        [reduce using rule 92 (assignment)]
    LT        [reduce using rule 92 (assignment)]
    MINUS     [reduce using rule 92 (assignment)]
    PLUS      [reduce using rule 92 (assignment)]
    MODULUS   [reduce using rule 92 (assignment)]
    DIVIDE    [reduce using rule 92 (assignment)]
    MULT      [reduce using rule 92 (assignment)]
    $default  reduce using rule 92 (assignment)


state 124

   39 expr: RPAREN . expr LPAREN
   69 idenFunc: defineIden LPAREN RPAREN .

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    NAME           [reduce using rule 69 (idenFunc)]
    INT            [reduce using rule 69 (idenFunc)]
    NUMBER         [reduce using rule 69 (idenFunc)]
    STRING         [reduce using rule 69 (idenFunc)]
    VALUE_BOOLEAN  [reduce using rule 69 (idenFunc)]
    VALUE_VOID     [reduce using rule 69 (idenFunc)]
    RPAREN         [reduce using rule 69 (idenFunc)]
    LPAREN         [reduce using rule 69 (idenFunc)]
    LBRACE         [reduce using rule 69 (idenFunc)]
    LBRACKET       [reduce using rule 69 (idenFunc)]
    $default       reduce using rule 69 (idenFunc)

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 93
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 125

   50 exprList: exprList . lists expr
   53         | exprList . endls
   68 idenFunc: defineIden LPAREN exprList . RPAREN

    ENDL    shift, and go to state 2
    RPAREN  shift, and go to state 178
    COMMA   shift, and go to state 80

    RPAREN    [reduce using rule 9 (lists)]
    $default  reduce using rule 9 (lists)

    endls  go to state 153
    list   go to state 149
    lists  go to state 154


state 126

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr
   70 idenBracket: defineIden LBRACKET expr . RBRACKET

    OR        shift, and go to state 102
    AND       shift, and go to state 103
    NE        shift, and go to state 104
    EQ        shift, and go to state 105
    GE        shift, and go to state 106
    GT        shift, and go to state 107
    LE        shift, and go to state 108
    LT        shift, and go to state 109
    MINUS     shift, and go to state 110
    PLUS      shift, and go to state 111
    MODULUS   shift, and go to state 112
    DIVIDE    shift, and go to state 113
    MULT      shift, and go to state 114
    RBRACKET  shift, and go to state 179


state 127

   80 elseIfPart: ELSE IF . LPAREN expr RPAREN @7 subSpace

    LPAREN  shift, and go to state 180


state 128

   80 elseIfPart: ELSE . IF LPAREN expr RPAREN @7 subSpace
   82 elsePart: ELSE . @8 subSpace

    IF  shift, and go to state 127

    IF        [reduce using rule 81 (@8)]
    $default  reduce using rule 81 (@8)

    @8  go to state 181


state 129

   74 defineIf: ifPart endlsn elseIfParts . endlsn elsePart
   77 elseIfParts: elseIfParts . endlsn elseIfPart

    ENDL  shift, and go to state 2

    $default  reduce using rule 3 (endlsn)

    endls   go to state 76
    endlsn  go to state 182


state 130

   73 defineIf: ifPart endlsn elsePart .

    $default  reduce using rule 73 (defineIf)


state 131

   77 elseIfParts: elseIfParts endlsn . elseIfPart

    ELSE  shift, and go to state 75

    elseIfPart  go to state 183


state 132

    1 endls: endls . ENDL
    8 list: list endls .

    ENDL  shift, and go to state 70

    ENDL      [reduce using rule 8 (list)]
    $default  reduce using rule 8 (list)


state 133

  108 paramListP: paramListP list defineParam .

    $default  reduce using rule 108 (paramListP)


state 134

  122 stats: stats stat endc .

    $default  reduce using rule 122 (stats)


state 135

   64 funcType: defineType COLON LPAREN . typeList RPAREN

    NAME    shift, and go to state 1
    LPAREN  shift, and go to state 4
    LBRACE  shift, and go to state 5

    $default  reduce using rule 155 (typeList)

    name        go to state 42
    arrayType   go to state 19
    dictType    go to state 20
    funcType    go to state 23
    defineType  go to state 184
    typeListP   go to state 185
    typeList    go to state 186


state 136

  107 defineParam: defineType name ASSIGN . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 187
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 137

   61 funcHeaderV: LPAREN . paramList RPAREN

    NAME    shift, and go to state 1
    ENDL    shift, and go to state 2
    LPAREN  shift, and go to state 4
    LBRACE  shift, and go to state 5

    ENDL      [reduce using rule 110 (paramList)]
    $default  reduce using rule 110 (paramList)

    endls        go to state 117
    name         go to state 42
    arrayType    go to state 19
    dictType     go to state 20
    funcType     go to state 23
    defineParam  go to state 32
    paramListP   go to state 118
    paramList    go to state 188
    defineType   go to state 69


state 138

   58 defineFunc: defineType name funcHeaderV . @3 subSpace

    $default  reduce using rule 57 (@3)

    @3  go to state 189


state 139

   16 arrayType: defineType . BRACKET
   64 funcType: defineType . COLON LPAREN typeList RPAREN
  151 typeListM: typeListM SOR defineType .

    COLON    shift, and go to state 84
    BRACKET  shift, and go to state 85

    $default  reduce using rule 151 (typeListM)


state 140

   86 initOperator: OPERATOR LBRACE . initOperatorContexts RBRACE endls

    NAME    shift, and go to state 1
    ENDL    shift, and go to state 2
    LPAREN  shift, and go to state 4
    LBRACE  shift, and go to state 5

    endls                 go to state 190
    name                  go to state 42
    arrayType             go to state 19
    dictType              go to state 20
    funcType              go to state 23
    initOperatorContexts  go to state 191
    initOperatorContext   go to state 192
    defineType            go to state 193


state 141

   83 init: DINIT endls initContext DEND .

    $default  reduce using rule 83 (init)


state 142

   39 expr: RPAREN expr LPAREN .

    $default  reduce using rule 39 (expr)


state 143

   63 funcHeaderE: LPAREN @5 paramList . RPAREN COLON defineType
  113 paramList: paramList . endls

    ENDL    shift, and go to state 2
    RPAREN  shift, and go to state 194

    endls  go to state 174


state 144

    1 endls: endls ENDL .
    2      | ENDL .

    OR             reduce using rule 1 (endls)
    OR             [reduce using rule 2 (endls)]
    AND            reduce using rule 1 (endls)
    AND            [reduce using rule 2 (endls)]
    NE             reduce using rule 1 (endls)
    NE             [reduce using rule 2 (endls)]
    EQ             reduce using rule 1 (endls)
    EQ             [reduce using rule 2 (endls)]
    GE             reduce using rule 1 (endls)
    GE             [reduce using rule 2 (endls)]
    GT             reduce using rule 1 (endls)
    GT             [reduce using rule 2 (endls)]
    LE             reduce using rule 1 (endls)
    LE             [reduce using rule 2 (endls)]
    LT             reduce using rule 1 (endls)
    LT             [reduce using rule 2 (endls)]
    MINUS          reduce using rule 1 (endls)
    MINUS          [reduce using rule 2 (endls)]
    PLUS           reduce using rule 1 (endls)
    PLUS           [reduce using rule 2 (endls)]
    MODULUS        reduce using rule 1 (endls)
    MODULUS        [reduce using rule 2 (endls)]
    DIVIDE         reduce using rule 1 (endls)
    DIVIDE         [reduce using rule 2 (endls)]
    MULT           reduce using rule 1 (endls)
    MULT           [reduce using rule 2 (endls)]
    NAME           reduce using rule 1 (endls)
    NAME           [reduce using rule 2 (endls)]
    ENDL           reduce using rule 1 (endls)
    ENDL           [reduce using rule 2 (endls)]
    INT            reduce using rule 1 (endls)
    INT            [reduce using rule 2 (endls)]
    NUMBER         reduce using rule 1 (endls)
    NUMBER         [reduce using rule 2 (endls)]
    STRING         reduce using rule 1 (endls)
    STRING         [reduce using rule 2 (endls)]
    VALUE_BOOLEAN  reduce using rule 1 (endls)
    VALUE_BOOLEAN  [reduce using rule 2 (endls)]
    VALUE_VOID     reduce using rule 1 (endls)
    VALUE_VOID     [reduce using rule 2 (endls)]
    SEMICOLON      reduce using rule 1 (endls)
    SEMICOLON      [reduce using rule 2 (endls)]
    RPAREN         reduce using rule 1 (endls)
    RPAREN         [reduce using rule 2 (endls)]
    LPAREN         reduce using rule 1 (endls)
    LPAREN         [reduce using rule 2 (endls)]
    RBRACE         reduce using rule 1 (endls)
    RBRACE         [reduce using rule 2 (endls)]
    LBRACE         reduce using rule 1 (endls)
    LBRACE         [reduce using rule 2 (endls)]
    COMMA          reduce using rule 1 (endls)
    COMMA          [reduce using rule 2 (endls)]
    RBRACKET       reduce using rule 1 (endls)
    RBRACKET       [reduce using rule 2 (endls)]
    LBRACKET       reduce using rule 1 (endls)
    LBRACKET       [reduce using rule 2 (endls)]
    RETURN         reduce using rule 1 (endls)
    RETURN         [reduce using rule 2 (endls)]
    IF             reduce using rule 1 (endls)
    IF             [reduce using rule 2 (endls)]
    ELSE           reduce using rule 1 (endls)
    ELSE           [reduce using rule 2 (endls)]
    FOR            reduce using rule 1 (endls)
    FOR            [reduce using rule 2 (endls)]
    WHILE          reduce using rule 1 (endls)
    WHILE          [reduce using rule 2 (endls)]
    SWITCH         reduce using rule 1 (endls)
    SWITCH         [reduce using rule 2 (endls)]
    CASE           reduce using rule 1 (endls)
    CASE           [reduce using rule 2 (endls)]
    DEFAULT        reduce using rule 1 (endls)
    DEFAULT        [reduce using rule 2 (endls)]
    BREAK          reduce using rule 1 (endls)
    BREAK          [reduce using rule 2 (endls)]
    CONTINUE       reduce using rule 1 (endls)
    CONTINUE       [reduce using rule 2 (endls)]
    CONST          reduce using rule 1 (endls)
    CONST          [reduce using rule 2 (endls)]
    $default       reduce using rule 1 (endls)


state 145

   21 dictContext: dictContext . lists dictList
   23            | endls dictContext .
   24            | dictContext . endls

    ENDL   shift, and go to state 2
    COMMA  shift, and go to state 80

    NAME      reduce using rule 9 (lists)
    NAME      [reduce using rule 23 (dictContext)]
    ENDL      [reduce using rule 23 (dictContext)]
    RBRACE    reduce using rule 23 (dictContext)
    COMMA     [reduce using rule 23 (dictContext)]
    $default  reduce using rule 9 (lists)

    endls  go to state 148
    list   go to state 149
    lists  go to state 150


state 146

   25 dictList: name expr .
   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr

    OR       shift, and go to state 102
    AND      shift, and go to state 103
    NE       shift, and go to state 104
    EQ       shift, and go to state 105
    GE       shift, and go to state 106
    GT       shift, and go to state 107
    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114

    $default  reduce using rule 25 (dictList)


state 147

   19 dictExpr: LBRACE dictContext RBRACE .

    $default  reduce using rule 19 (dictExpr)


state 148

    1 endls: endls . ENDL
   11 lists: endls .
   24 dictContext: dictContext endls .

    ENDL  shift, and go to state 70

    NAME      reduce using rule 11 (lists)
    NAME      [reduce using rule 24 (dictContext)]
    ENDL      [reduce using rule 24 (dictContext)]
    $default  reduce using rule 24 (dictContext)


state 149

    8 list: list . endls
   10 lists: list .

    ENDL  shift, and go to state 2

    $default  reduce using rule 10 (lists)

    endls  go to state 132


state 150

   21 dictContext: dictContext lists . dictList

    NAME  shift, and go to state 1

    name      go to state 96
    dictList  go to state 195


state 151

   50 exprList: exprList . lists expr
   52         | endls exprList .
   53         | exprList . endls

    ENDL   shift, and go to state 2
    COMMA  shift, and go to state 80

    NAME           reduce using rule 9 (lists)
    NAME           [reduce using rule 52 (exprList)]
    ENDL           [reduce using rule 52 (exprList)]
    INT            reduce using rule 9 (lists)
    INT            [reduce using rule 52 (exprList)]
    NUMBER         reduce using rule 9 (lists)
    NUMBER         [reduce using rule 52 (exprList)]
    STRING         reduce using rule 9 (lists)
    STRING         [reduce using rule 52 (exprList)]
    VALUE_BOOLEAN  reduce using rule 9 (lists)
    VALUE_BOOLEAN  [reduce using rule 52 (exprList)]
    VALUE_VOID     reduce using rule 9 (lists)
    VALUE_VOID     [reduce using rule 52 (exprList)]
    RPAREN         reduce using rule 9 (lists)
    RPAREN         [reduce using rule 52 (exprList)]
    LPAREN         reduce using rule 9 (lists)
    LPAREN         [reduce using rule 52 (exprList)]
    LBRACE         reduce using rule 9 (lists)
    LBRACE         [reduce using rule 52 (exprList)]
    COMMA          [reduce using rule 52 (exprList)]
    RBRACKET       reduce using rule 52 (exprList)
    LBRACKET       reduce using rule 9 (lists)
    LBRACKET       [reduce using rule 52 (exprList)]
    $default       reduce using rule 9 (lists)

    endls  go to state 153
    list   go to state 149
    lists  go to state 154


state 152

   17 arrayExpr: LBRACKET exprList RBRACKET .

    $default  reduce using rule 17 (arrayExpr)


state 153

    1 endls: endls . ENDL
   11 lists: endls .
   53 exprList: exprList endls .

    ENDL  shift, and go to state 70

    NAME           reduce using rule 11 (lists)
    NAME           [reduce using rule 53 (exprList)]
    ENDL           [reduce using rule 53 (exprList)]
    INT            reduce using rule 11 (lists)
    INT            [reduce using rule 53 (exprList)]
    NUMBER         reduce using rule 11 (lists)
    NUMBER         [reduce using rule 53 (exprList)]
    STRING         reduce using rule 11 (lists)
    STRING         [reduce using rule 53 (exprList)]
    VALUE_BOOLEAN  reduce using rule 11 (lists)
    VALUE_BOOLEAN  [reduce using rule 53 (exprList)]
    VALUE_VOID     reduce using rule 11 (lists)
    VALUE_VOID     [reduce using rule 53 (exprList)]
    RPAREN         reduce using rule 11 (lists)
    RPAREN         [reduce using rule 53 (exprList)]
    LPAREN         reduce using rule 11 (lists)
    LPAREN         [reduce using rule 53 (exprList)]
    LBRACE         reduce using rule 11 (lists)
    LBRACE         [reduce using rule 53 (exprList)]
    COMMA          reduce using rule 53 (exprList)
    RBRACKET       reduce using rule 53 (exprList)
    LBRACKET       reduce using rule 11 (lists)
    LBRACKET       [reduce using rule 53 (exprList)]
    $default       reduce using rule 11 (lists)


state 154

   50 exprList: exprList lists . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 196
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 155

   26 expr: expr . AND expr
   27     | expr . OR expr
   27     | expr OR expr .
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr

    NE       shift, and go to state 104
    EQ       shift, and go to state 105
    GE       shift, and go to state 106
    GT       shift, and go to state 107
    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114

    $default  reduce using rule 27 (expr)


state 156

   26 expr: expr . AND expr
   26     | expr AND expr .
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr

    NE       shift, and go to state 104
    EQ       shift, and go to state 105
    GE       shift, and go to state 106
    GT       shift, and go to state 107
    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114

    $default  reduce using rule 26 (expr)


state 157

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   29     | expr NE expr .
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr

    GE       shift, and go to state 106
    GT       shift, and go to state 107
    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114

    $default  reduce using rule 29 (expr)


state 158

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   28     | expr EQ expr .
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr

    GE       shift, and go to state 106
    GT       shift, and go to state 107
    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114

    $default  reduce using rule 28 (expr)


state 159

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   31     | expr GE expr .
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr

    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114

    $default  reduce using rule 31 (expr)


state 160

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   30     | expr GT expr .
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr

    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114

    $default  reduce using rule 30 (expr)


state 161

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   33     | expr LE expr .
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr

    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114

    $default  reduce using rule 33 (expr)


state 162

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   32     | expr LT expr .
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr

    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114

    $default  reduce using rule 32 (expr)


state 163

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   35     | expr MINUS expr .
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr

    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114

    $default  reduce using rule 35 (expr)


state 164

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   34     | expr PLUS expr .
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr

    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114

    $default  reduce using rule 34 (expr)


state 165

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr
   38     | expr MODULUS expr .

    $default  reduce using rule 38 (expr)


state 166

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   37     | expr DIVIDE expr .
   38     | expr . MODULUS expr

    $default  reduce using rule 37 (expr)


state 167

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   36     | expr MULT expr .
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr

    $default  reduce using rule 36 (expr)


state 168

   18 dictType: LBRACE . defineType RBRACE
  114 subSpace: LBRACE . endlsn stats RBRACE
  116         | LBRACE . endlsn stat endlsn RBRACE

    NAME    shift, and go to state 1
    ENDL    shift, and go to state 2
    LPAREN  shift, and go to state 4
    LBRACE  shift, and go to state 5

    NAME      [reduce using rule 3 (endlsn)]
    ENDL      [reduce using rule 3 (endlsn)]
    LPAREN    [reduce using rule 3 (endlsn)]
    LBRACE    [reduce using rule 3 (endlsn)]
    $default  reduce using rule 3 (endlsn)

    endls       go to state 76
    endlsn      go to state 197
    name        go to state 42
    arrayType   go to state 19
    dictType    go to state 20
    funcType    go to state 23
    defineType  go to state 45


state 169

    1 endls: endls . ENDL
    6 endc: endls .
  117 subSpace: endls . subSpace

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 144
    SEMICOLON  shift, and go to state 3
    LPAREN     shift, and go to state 4
    LBRACE     shift, and go to state 168
    RETURN     shift, and go to state 7
    IF         shift, and go to state 8
    FOR        shift, and go to state 9
    WHILE      shift, and go to state 10
    SWITCH     shift, and go to state 11
    BREAK      shift, and go to state 12
    CONTINUE   shift, and go to state 13
    CONST      shift, and go to state 14

    OR             reduce using rule 6 (endc)
    OR             [reduce using rule 91 (assignment)]
    AND            reduce using rule 6 (endc)
    AND            [reduce using rule 91 (assignment)]
    NE             reduce using rule 6 (endc)
    NE             [reduce using rule 91 (assignment)]
    EQ             reduce using rule 6 (endc)
    EQ             [reduce using rule 91 (assignment)]
    GE             reduce using rule 6 (endc)
    GE             [reduce using rule 91 (assignment)]
    GT             reduce using rule 6 (endc)
    GT             [reduce using rule 91 (assignment)]
    LE             reduce using rule 6 (endc)
    LE             [reduce using rule 91 (assignment)]
    LT             reduce using rule 6 (endc)
    LT             [reduce using rule 91 (assignment)]
    MINUS          reduce using rule 6 (endc)
    MINUS          [reduce using rule 91 (assignment)]
    PLUS           reduce using rule 6 (endc)
    PLUS           [reduce using rule 91 (assignment)]
    MODULUS        reduce using rule 6 (endc)
    MODULUS        [reduce using rule 91 (assignment)]
    DIVIDE         reduce using rule 6 (endc)
    DIVIDE         [reduce using rule 91 (assignment)]
    MULT           reduce using rule 6 (endc)
    MULT           [reduce using rule 91 (assignment)]
    NAME           [reduce using rule 6 (endc)]
    NAME           [reduce using rule 91 (assignment)]
    ENDL           [reduce using rule 6 (endc)]
    ENDL           [reduce using rule 91 (assignment)]
    INT            reduce using rule 6 (endc)
    INT            [reduce using rule 91 (assignment)]
    NUMBER         reduce using rule 6 (endc)
    NUMBER         [reduce using rule 91 (assignment)]
    STRING         reduce using rule 6 (endc)
    STRING         [reduce using rule 91 (assignment)]
    VALUE_BOOLEAN  reduce using rule 6 (endc)
    VALUE_BOOLEAN  [reduce using rule 91 (assignment)]
    VALUE_VOID     reduce using rule 6 (endc)
    VALUE_VOID     [reduce using rule 91 (assignment)]
    SEMICOLON      [reduce using rule 6 (endc)]
    SEMICOLON      [reduce using rule 91 (assignment)]
    RPAREN         reduce using rule 6 (endc)
    RPAREN         [reduce using rule 91 (assignment)]
    LPAREN         [reduce using rule 6 (endc)]
    LPAREN         [reduce using rule 91 (assignment)]
    RBRACE         reduce using rule 6 (endc)
    RBRACE         [reduce using rule 91 (assignment)]
    LBRACE         [reduce using rule 6 (endc)]
    LBRACE         [reduce using rule 91 (assignment)]
    COMMA          reduce using rule 6 (endc)
    COMMA          [reduce using rule 91 (assignment)]
    RBRACKET       reduce using rule 6 (endc)
    RBRACKET       [reduce using rule 91 (assignment)]
    LBRACKET       reduce using rule 6 (endc)
    LBRACKET       [reduce using rule 91 (assignment)]
    ELSE           reduce using rule 6 (endc)
    ELSE           [reduce using rule 91 (assignment)]
    CASE           reduce using rule 6 (endc)
    CASE           [reduce using rule 91 (assignment)]
    DEFAULT        reduce using rule 6 (endc)
    DEFAULT        [reduce using rule 91 (assignment)]
    $default       reduce using rule 6 (endc)

    endls          go to state 169
    endc           go to state 16
    name           go to state 17
    arrayType      go to state 19
    dictType       go to state 20
    defineFor      go to state 21
    defineFunc     go to state 22
    funcType       go to state 23
    defineIden     go to state 24
    idenFunc       go to state 25
    idenBracket    go to state 26
    defineIf       go to state 27
    ifPart         go to state 28
    assignment     go to state 30
    iteration      go to state 31
    defineParam    go to state 32
    paramListP     go to state 33
    subSpace       go to state 198
    controlSpace   go to state 34
    stat           go to state 171
    defineStat     go to state 37
    defineSwitch   go to state 38
    defineType     go to state 39
    defineVariale  go to state 40
    defineWhile    go to state 41


state 170

   60 funcExpr: funcHeaderE @4 subSpace .

    $default  reduce using rule 60 (funcExpr)


state 171

  115 subSpace: stat .

    $default  reduce using rule 115 (subSpace)


state 172

   76 ifPart: IF LPAREN expr RPAREN . @6 subSpace

    $default  reduce using rule 75 (@6)

    @6  go to state 199


state 173

  112 paramList: endls paramList .
  113          | paramList . endls

    ENDL  shift, and go to state 2

    ENDL      [reduce using rule 112 (paramList)]
    $default  reduce using rule 112 (paramList)

    endls  go to state 174


state 174

    1 endls: endls . ENDL
  113 paramList: paramList endls .

    ENDL  shift, and go to state 70

    ENDL      [reduce using rule 113 (paramList)]
    $default  reduce using rule 113 (paramList)


state 175

   56 defineFor: FOR LPAREN paramList @1 . SEMICOLON expr SEMICOLON iteration RPAREN @2 subSpace

    SEMICOLON  shift, and go to state 200


state 176

  160 defineWhile: WHILE LPAREN expr RPAREN . @12 subSpace

    $default  reduce using rule 159 (@12)

    @12  go to state 201


state 177

  135 defineSwitch: SWITCH LPAREN expr RPAREN . @9 switchSpace

    $default  reduce using rule 134 (@9)

    @9  go to state 202


state 178

   68 idenFunc: defineIden LPAREN exprList RPAREN .

    $default  reduce using rule 68 (idenFunc)


state 179

   70 idenBracket: defineIden LBRACKET expr RBRACKET .

    $default  reduce using rule 70 (idenBracket)


state 180

   80 elseIfPart: ELSE IF LPAREN . expr RPAREN @7 subSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 203
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 181

   82 elsePart: ELSE @8 . subSpace

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    LPAREN     shift, and go to state 4
    LBRACE     shift, and go to state 168
    RETURN     shift, and go to state 7
    IF         shift, and go to state 8
    FOR        shift, and go to state 9
    WHILE      shift, and go to state 10
    SWITCH     shift, and go to state 11
    BREAK      shift, and go to state 12
    CONTINUE   shift, and go to state 13
    CONST      shift, and go to state 14

    NAME       [reduce using rule 91 (assignment)]
    ENDL       [reduce using rule 91 (assignment)]
    SEMICOLON  [reduce using rule 91 (assignment)]
    LPAREN     [reduce using rule 91 (assignment)]
    LBRACE     [reduce using rule 91 (assignment)]
    $default   reduce using rule 91 (assignment)

    endls          go to state 169
    endc           go to state 16
    name           go to state 17
    arrayType      go to state 19
    dictType       go to state 20
    defineFor      go to state 21
    defineFunc     go to state 22
    funcType       go to state 23
    defineIden     go to state 24
    idenFunc       go to state 25
    idenBracket    go to state 26
    defineIf       go to state 27
    ifPart         go to state 28
    assignment     go to state 30
    iteration      go to state 31
    defineParam    go to state 32
    paramListP     go to state 33
    subSpace       go to state 204
    controlSpace   go to state 34
    stat           go to state 171
    defineStat     go to state 37
    defineSwitch   go to state 38
    defineType     go to state 39
    defineVariale  go to state 40
    defineWhile    go to state 41


state 182

   74 defineIf: ifPart endlsn elseIfParts endlsn . elsePart
   77 elseIfParts: elseIfParts endlsn . elseIfPart

    ELSE  shift, and go to state 128

    elseIfPart  go to state 183
    elsePart    go to state 205


state 183

   77 elseIfParts: elseIfParts endlsn elseIfPart .

    $default  reduce using rule 77 (elseIfParts)


state 184

   16 arrayType: defineType . BRACKET
   64 funcType: defineType . COLON LPAREN typeList RPAREN
  154 typeListP: defineType .

    COLON    shift, and go to state 84
    BRACKET  shift, and go to state 85

    $default  reduce using rule 154 (typeListP)


state 185

  153 typeListP: typeListP . list defineType
  156 typeList: typeListP .

    COMMA  shift, and go to state 80

    $default  reduce using rule 156 (typeList)

    list  go to state 206


state 186

   64 funcType: defineType COLON LPAREN typeList . RPAREN

    RPAREN  shift, and go to state 207


state 187

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr
  107 defineParam: defineType name ASSIGN expr .

    OR       shift, and go to state 102
    AND      shift, and go to state 103
    NE       shift, and go to state 104
    EQ       shift, and go to state 105
    GE       shift, and go to state 106
    GT       shift, and go to state 107
    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114

    OR        [reduce using rule 107 (defineParam)]
    AND       [reduce using rule 107 (defineParam)]
    NE        [reduce using rule 107 (defineParam)]
    EQ        [reduce using rule 107 (defineParam)]
    GE        [reduce using rule 107 (defineParam)]
    GT        [reduce using rule 107 (defineParam)]
    LE        [reduce using rule 107 (defineParam)]
    LT        [reduce using rule 107 (defineParam)]
    MINUS     [reduce using rule 107 (defineParam)]
    PLUS      [reduce using rule 107 (defineParam)]
    MODULUS   [reduce using rule 107 (defineParam)]
    DIVIDE    [reduce using rule 107 (defineParam)]
    MULT      [reduce using rule 107 (defineParam)]
    $default  reduce using rule 107 (defineParam)


state 188

   61 funcHeaderV: LPAREN paramList . RPAREN
  113 paramList: paramList . endls

    ENDL    shift, and go to state 2
    RPAREN  shift, and go to state 208

    endls  go to state 174


state 189

   58 defineFunc: defineType name funcHeaderV @3 . subSpace

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    LPAREN     shift, and go to state 4
    LBRACE     shift, and go to state 168
    RETURN     shift, and go to state 7
    IF         shift, and go to state 8
    FOR        shift, and go to state 9
    WHILE      shift, and go to state 10
    SWITCH     shift, and go to state 11
    BREAK      shift, and go to state 12
    CONTINUE   shift, and go to state 13
    CONST      shift, and go to state 14

    NAME       [reduce using rule 91 (assignment)]
    ENDL       [reduce using rule 91 (assignment)]
    SEMICOLON  [reduce using rule 91 (assignment)]
    LPAREN     [reduce using rule 91 (assignment)]
    LBRACE     [reduce using rule 91 (assignment)]
    $default   reduce using rule 91 (assignment)

    endls          go to state 169
    endc           go to state 16
    name           go to state 17
    arrayType      go to state 19
    dictType       go to state 20
    defineFor      go to state 21
    defineFunc     go to state 22
    funcType       go to state 23
    defineIden     go to state 24
    idenFunc       go to state 25
    idenBracket    go to state 26
    defineIf       go to state 27
    ifPart         go to state 28
    assignment     go to state 30
    iteration      go to state 31
    defineParam    go to state 32
    paramListP     go to state 33
    subSpace       go to state 209
    controlSpace   go to state 34
    stat           go to state 171
    defineStat     go to state 37
    defineSwitch   go to state 38
    defineType     go to state 39
    defineVariale  go to state 40
    defineWhile    go to state 41


state 190

    1 endls: endls . ENDL
   89 initOperatorContext: endls .

    ENDL  shift, and go to state 70

    ENDL      [reduce using rule 89 (initOperatorContext)]
    $default  reduce using rule 89 (initOperatorContext)


state 191

   86 initOperator: OPERATOR LBRACE initOperatorContexts . RBRACE endls
   87 initOperatorContexts: initOperatorContexts . initOperatorContext

    NAME    shift, and go to state 1
    ENDL    shift, and go to state 2
    LPAREN  shift, and go to state 4
    RBRACE  shift, and go to state 210
    LBRACE  shift, and go to state 5

    endls                go to state 190
    name                 go to state 42
    arrayType            go to state 19
    dictType             go to state 20
    funcType             go to state 23
    initOperatorContext  go to state 211
    defineType           go to state 193


state 192

   88 initOperatorContexts: initOperatorContext .

    $default  reduce using rule 88 (initOperatorContexts)


state 193

   16 arrayType: defineType . BRACKET
   64 funcType: defineType . COLON LPAREN typeList RPAREN
   90 initOperatorContext: defineType . operator defineType ASSIGN name endls

    NE       shift, and go to state 212
    EQ       shift, and go to state 213
    GE       shift, and go to state 214
    GT       shift, and go to state 215
    LE       shift, and go to state 216
    LT       shift, and go to state 217
    MINUS    shift, and go to state 218
    PLUS     shift, and go to state 219
    MODULUS  shift, and go to state 220
    DIVIDE   shift, and go to state 221
    MULT     shift, and go to state 222
    COLON    shift, and go to state 84
    BRACKET  shift, and go to state 85

    operator  go to state 223


state 194

   63 funcHeaderE: LPAREN @5 paramList RPAREN . COLON defineType

    COLON  shift, and go to state 224


state 195

   21 dictContext: dictContext lists dictList .

    $default  reduce using rule 21 (dictContext)


state 196

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr
   50 exprList: exprList lists expr .

    OR       shift, and go to state 102
    AND      shift, and go to state 103
    NE       shift, and go to state 104
    EQ       shift, and go to state 105
    GE       shift, and go to state 106
    GT       shift, and go to state 107
    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114

    $default  reduce using rule 50 (exprList)


state 197

  114 subSpace: LBRACE endlsn . stats RBRACE
  116         | LBRACE endlsn . stat endlsn RBRACE

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    LPAREN     shift, and go to state 4
    LBRACE     shift, and go to state 5
    RETURN     shift, and go to state 7
    IF         shift, and go to state 8
    FOR        shift, and go to state 9
    WHILE      shift, and go to state 10
    SWITCH     shift, and go to state 11
    BREAK      shift, and go to state 12
    CONTINUE   shift, and go to state 13
    CONST      shift, and go to state 14

    ENDL       [reduce using rule 91 (assignment)]
    SEMICOLON  [reduce using rule 91 (assignment)]
    $default   reduce using rule 91 (assignment)

    endls          go to state 15
    endc           go to state 16
    name           go to state 17
    arrayType      go to state 19
    dictType       go to state 20
    defineFor      go to state 21
    defineFunc     go to state 22
    funcType       go to state 23
    defineIden     go to state 24
    idenFunc       go to state 25
    idenBracket    go to state 26
    defineIf       go to state 27
    ifPart         go to state 28
    assignment     go to state 30
    iteration      go to state 31
    defineParam    go to state 32
    paramListP     go to state 33
    controlSpace   go to state 34
    stats          go to state 225
    stat           go to state 226
    defineStat     go to state 37
    defineSwitch   go to state 38
    defineType     go to state 39
    defineVariale  go to state 40
    defineWhile    go to state 41


state 198

  117 subSpace: endls subSpace .

    $default  reduce using rule 117 (subSpace)


state 199

   76 ifPart: IF LPAREN expr RPAREN @6 . subSpace

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    LPAREN     shift, and go to state 4
    LBRACE     shift, and go to state 168
    RETURN     shift, and go to state 7
    IF         shift, and go to state 8
    FOR        shift, and go to state 9
    WHILE      shift, and go to state 10
    SWITCH     shift, and go to state 11
    BREAK      shift, and go to state 12
    CONTINUE   shift, and go to state 13
    CONST      shift, and go to state 14

    NAME       [reduce using rule 91 (assignment)]
    ENDL       [reduce using rule 91 (assignment)]
    SEMICOLON  [reduce using rule 91 (assignment)]
    LPAREN     [reduce using rule 91 (assignment)]
    LBRACE     [reduce using rule 91 (assignment)]
    $default   reduce using rule 91 (assignment)

    endls          go to state 169
    endc           go to state 16
    name           go to state 17
    arrayType      go to state 19
    dictType       go to state 20
    defineFor      go to state 21
    defineFunc     go to state 22
    funcType       go to state 23
    defineIden     go to state 24
    idenFunc       go to state 25
    idenBracket    go to state 26
    defineIf       go to state 27
    ifPart         go to state 28
    assignment     go to state 30
    iteration      go to state 31
    defineParam    go to state 32
    paramListP     go to state 33
    subSpace       go to state 227
    controlSpace   go to state 34
    stat           go to state 171
    defineStat     go to state 37
    defineSwitch   go to state 38
    defineType     go to state 39
    defineVariale  go to state 40
    defineWhile    go to state 41


state 200

   56 defineFor: FOR LPAREN paramList @1 SEMICOLON . expr SEMICOLON iteration RPAREN @2 subSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 228
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 201

  160 defineWhile: WHILE LPAREN expr RPAREN @12 . subSpace

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    LPAREN     shift, and go to state 4
    LBRACE     shift, and go to state 168
    RETURN     shift, and go to state 7
    IF         shift, and go to state 8
    FOR        shift, and go to state 9
    WHILE      shift, and go to state 10
    SWITCH     shift, and go to state 11
    BREAK      shift, and go to state 12
    CONTINUE   shift, and go to state 13
    CONST      shift, and go to state 14

    NAME       [reduce using rule 91 (assignment)]
    ENDL       [reduce using rule 91 (assignment)]
    SEMICOLON  [reduce using rule 91 (assignment)]
    LPAREN     [reduce using rule 91 (assignment)]
    LBRACE     [reduce using rule 91 (assignment)]
    $default   reduce using rule 91 (assignment)

    endls          go to state 169
    endc           go to state 16
    name           go to state 17
    arrayType      go to state 19
    dictType       go to state 20
    defineFor      go to state 21
    defineFunc     go to state 22
    funcType       go to state 23
    defineIden     go to state 24
    idenFunc       go to state 25
    idenBracket    go to state 26
    defineIf       go to state 27
    ifPart         go to state 28
    assignment     go to state 30
    iteration      go to state 31
    defineParam    go to state 32
    paramListP     go to state 33
    subSpace       go to state 229
    controlSpace   go to state 34
    stat           go to state 171
    defineStat     go to state 37
    defineSwitch   go to state 38
    defineType     go to state 39
    defineVariale  go to state 40
    defineWhile    go to state 41


state 202

  135 defineSwitch: SWITCH LPAREN expr RPAREN @9 . switchSpace

    ENDL    shift, and go to state 2
    LBRACE  shift, and go to state 230

    endls        go to state 231
    switchSpace  go to state 232


state 203

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr
   80 elseIfPart: ELSE IF LPAREN expr . RPAREN @7 subSpace

    OR       shift, and go to state 102
    AND      shift, and go to state 103
    NE       shift, and go to state 104
    EQ       shift, and go to state 105
    GE       shift, and go to state 106
    GT       shift, and go to state 107
    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114
    RPAREN   shift, and go to state 233


state 204

   82 elsePart: ELSE @8 subSpace .

    $default  reduce using rule 82 (elsePart)


state 205

   74 defineIf: ifPart endlsn elseIfParts endlsn elsePart .

    $default  reduce using rule 74 (defineIf)


state 206

    8 list: list . endls
  153 typeListP: typeListP list . defineType

    NAME    shift, and go to state 1
    ENDL    shift, and go to state 2
    LPAREN  shift, and go to state 4
    LBRACE  shift, and go to state 5

    endls       go to state 132
    name        go to state 42
    arrayType   go to state 19
    dictType    go to state 20
    funcType    go to state 23
    defineType  go to state 234


state 207

   64 funcType: defineType COLON LPAREN typeList RPAREN .

    $default  reduce using rule 64 (funcType)


state 208

   61 funcHeaderV: LPAREN paramList RPAREN .

    $default  reduce using rule 61 (funcHeaderV)


state 209

   58 defineFunc: defineType name funcHeaderV @3 subSpace .

    $default  reduce using rule 58 (defineFunc)


state 210

   86 initOperator: OPERATOR LBRACE initOperatorContexts RBRACE . endls

    ENDL  shift, and go to state 2

    endls  go to state 235


state 211

   87 initOperatorContexts: initOperatorContexts initOperatorContext .

    $default  reduce using rule 87 (initOperatorContexts)


state 212

  101 operator: NE .

    $default  reduce using rule 101 (operator)


state 213

  100 operator: EQ .

    $default  reduce using rule 100 (operator)


state 214

  103 operator: GE .

    $default  reduce using rule 103 (operator)


state 215

  102 operator: GT .

    $default  reduce using rule 102 (operator)


state 216

  105 operator: LE .

    $default  reduce using rule 105 (operator)


state 217

  104 operator: LT .

    $default  reduce using rule 104 (operator)


state 218

   96 operator: MINUS .

    $default  reduce using rule 96 (operator)


state 219

   95 operator: PLUS .

    $default  reduce using rule 95 (operator)


state 220

   99 operator: MODULUS .

    $default  reduce using rule 99 (operator)


state 221

   98 operator: DIVIDE .

    $default  reduce using rule 98 (operator)


state 222

   97 operator: MULT .

    $default  reduce using rule 97 (operator)


state 223

   90 initOperatorContext: defineType operator . defineType ASSIGN name endls

    NAME    shift, and go to state 1
    LPAREN  shift, and go to state 4
    LBRACE  shift, and go to state 5

    name        go to state 42
    arrayType   go to state 19
    dictType    go to state 20
    funcType    go to state 23
    defineType  go to state 236


state 224

   63 funcHeaderE: LPAREN @5 paramList RPAREN COLON . defineType

    NAME    shift, and go to state 1
    LPAREN  shift, and go to state 4
    LBRACE  shift, and go to state 5

    name        go to state 42
    arrayType   go to state 19
    dictType    go to state 20
    funcType    go to state 23
    defineType  go to state 237


state 225

  114 subSpace: LBRACE endlsn stats . RBRACE
  122 stats: stats . stat endc

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    LPAREN     shift, and go to state 4
    RBRACE     shift, and go to state 238
    LBRACE     shift, and go to state 5
    RETURN     shift, and go to state 7
    IF         shift, and go to state 8
    FOR        shift, and go to state 9
    WHILE      shift, and go to state 10
    SWITCH     shift, and go to state 11
    BREAK      shift, and go to state 12
    CONTINUE   shift, and go to state 13
    CONST      shift, and go to state 14

    ENDL       [reduce using rule 91 (assignment)]
    SEMICOLON  [reduce using rule 91 (assignment)]

    endls          go to state 15
    endc           go to state 16
    name           go to state 17
    arrayType      go to state 19
    dictType       go to state 20
    defineFor      go to state 21
    defineFunc     go to state 22
    funcType       go to state 23
    defineIden     go to state 24
    idenFunc       go to state 25
    idenBracket    go to state 26
    defineIf       go to state 27
    ifPart         go to state 28
    assignment     go to state 30
    iteration      go to state 31
    defineParam    go to state 32
    paramListP     go to state 33
    controlSpace   go to state 34
    stat           go to state 82
    defineStat     go to state 37
    defineSwitch   go to state 38
    defineType     go to state 39
    defineVariale  go to state 40
    defineWhile    go to state 41


state 226

  116 subSpace: LBRACE endlsn stat . endlsn RBRACE
  123 stats: stat . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    $default  reduce using rule 3 (endlsn)

    endls   go to state 239
    endlsn  go to state 240
    endc    go to state 83


state 227

   76 ifPart: IF LPAREN expr RPAREN @6 subSpace .

    $default  reduce using rule 76 (ifPart)


state 228

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr
   56 defineFor: FOR LPAREN paramList @1 SEMICOLON expr . SEMICOLON iteration RPAREN @2 subSpace

    OR         shift, and go to state 102
    AND        shift, and go to state 103
    NE         shift, and go to state 104
    EQ         shift, and go to state 105
    GE         shift, and go to state 106
    GT         shift, and go to state 107
    LE         shift, and go to state 108
    LT         shift, and go to state 109
    MINUS      shift, and go to state 110
    PLUS       shift, and go to state 111
    MODULUS    shift, and go to state 112
    DIVIDE     shift, and go to state 113
    MULT       shift, and go to state 114
    SEMICOLON  shift, and go to state 241


state 229

  160 defineWhile: WHILE LPAREN expr RPAREN @12 subSpace .

    $default  reduce using rule 160 (defineWhile)


state 230

  136 switchSpace: LBRACE . switchStats RBRACE

    ENDL     shift, and go to state 2
    CASE     shift, and go to state 242
    DEFAULT  shift, and go to state 243

    ENDL      [reduce using rule 140 (switchStat)]
    CASE      [reduce using rule 140 (switchStat)]
    DEFAULT   [reduce using rule 140 (switchStat)]
    $default  reduce using rule 140 (switchStat)

    endls        go to state 244
    switchStats  go to state 245
    switchStat   go to state 246


state 231

    1 endls: endls . ENDL
  137 switchSpace: endls . switchSpace

    ENDL    shift, and go to state 144
    LBRACE  shift, and go to state 230

    endls        go to state 231
    switchSpace  go to state 247


state 232

  135 defineSwitch: SWITCH LPAREN expr RPAREN @9 switchSpace .

    $default  reduce using rule 135 (defineSwitch)


state 233

   80 elseIfPart: ELSE IF LPAREN expr RPAREN . @7 subSpace

    $default  reduce using rule 79 (@7)

    @7  go to state 248


state 234

   16 arrayType: defineType . BRACKET
   64 funcType: defineType . COLON LPAREN typeList RPAREN
  153 typeListP: typeListP list defineType .

    COLON    shift, and go to state 84
    BRACKET  shift, and go to state 85

    $default  reduce using rule 153 (typeListP)


state 235

    1 endls: endls . ENDL
   86 initOperator: OPERATOR LBRACE initOperatorContexts RBRACE endls .

    ENDL  shift, and go to state 70

    $default  reduce using rule 86 (initOperator)


state 236

   16 arrayType: defineType . BRACKET
   64 funcType: defineType . COLON LPAREN typeList RPAREN
   90 initOperatorContext: defineType operator defineType . ASSIGN name endls

    COLON    shift, and go to state 84
    ASSIGN   shift, and go to state 249
    BRACKET  shift, and go to state 85


state 237

   16 arrayType: defineType . BRACKET
   63 funcHeaderE: LPAREN @5 paramList RPAREN COLON defineType .
   64 funcType: defineType . COLON LPAREN typeList RPAREN

    COLON    shift, and go to state 84
    BRACKET  shift, and go to state 85

    $default  reduce using rule 63 (funcHeaderE)


state 238

  114 subSpace: LBRACE endlsn stats RBRACE .

    $default  reduce using rule 114 (subSpace)


state 239

    1 endls: endls . ENDL
    4 endlsn: endls .
    6 endc: endls .

    ENDL  shift, and go to state 70

    ENDL      [reduce using rule 6 (endc)]
    RBRACE    reduce using rule 4 (endlsn)
    RBRACE    [reduce using rule 6 (endc)]
    $default  reduce using rule 6 (endc)


state 240

  116 subSpace: LBRACE endlsn stat endlsn . RBRACE

    RBRACE  shift, and go to state 250


state 241

   56 defineFor: FOR LPAREN paramList @1 SEMICOLON expr SEMICOLON . iteration RPAREN @2 subSpace

    NAME  shift, and go to state 1

    $default  reduce using rule 91 (assignment)

    name         go to state 56
    defineIden   go to state 24
    idenFunc     go to state 25
    idenBracket  go to state 26
    assignment   go to state 30
    iteration    go to state 251


state 242

  143 switchStat: CASE . LPAREN expr RPAREN @10 subSpace

    LPAREN  shift, and go to state 252


state 243

  145 switchStat: DEFAULT . @11 subSpace

    $default  reduce using rule 144 (@11)

    @11  go to state 253


state 244

    1 endls: endls . ENDL
  141 switchStat: endls .

    ENDL  shift, and go to state 70

    ENDL      [reduce using rule 141 (switchStat)]
    $default  reduce using rule 141 (switchStat)


state 245

  136 switchSpace: LBRACE switchStats . RBRACE
  138 switchStats: switchStats . switchStat

    ENDL     shift, and go to state 2
    RBRACE   shift, and go to state 254
    CASE     shift, and go to state 242
    DEFAULT  shift, and go to state 243

    ENDL     [reduce using rule 140 (switchStat)]
    RBRACE   [reduce using rule 140 (switchStat)]
    CASE     [reduce using rule 140 (switchStat)]
    DEFAULT  [reduce using rule 140 (switchStat)]

    endls       go to state 244
    switchStat  go to state 255


state 246

  139 switchStats: switchStat .

    $default  reduce using rule 139 (switchStats)


state 247

  137 switchSpace: endls switchSpace .

    $default  reduce using rule 137 (switchSpace)


state 248

   80 elseIfPart: ELSE IF LPAREN expr RPAREN @7 . subSpace

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    LPAREN     shift, and go to state 4
    LBRACE     shift, and go to state 168
    RETURN     shift, and go to state 7
    IF         shift, and go to state 8
    FOR        shift, and go to state 9
    WHILE      shift, and go to state 10
    SWITCH     shift, and go to state 11
    BREAK      shift, and go to state 12
    CONTINUE   shift, and go to state 13
    CONST      shift, and go to state 14

    NAME       [reduce using rule 91 (assignment)]
    ENDL       [reduce using rule 91 (assignment)]
    SEMICOLON  [reduce using rule 91 (assignment)]
    LPAREN     [reduce using rule 91 (assignment)]
    LBRACE     [reduce using rule 91 (assignment)]
    $default   reduce using rule 91 (assignment)

    endls          go to state 169
    endc           go to state 16
    name           go to state 17
    arrayType      go to state 19
    dictType       go to state 20
    defineFor      go to state 21
    defineFunc     go to state 22
    funcType       go to state 23
    defineIden     go to state 24
    idenFunc       go to state 25
    idenBracket    go to state 26
    defineIf       go to state 27
    ifPart         go to state 28
    assignment     go to state 30
    iteration      go to state 31
    defineParam    go to state 32
    paramListP     go to state 33
    subSpace       go to state 256
    controlSpace   go to state 34
    stat           go to state 171
    defineStat     go to state 37
    defineSwitch   go to state 38
    defineType     go to state 39
    defineVariale  go to state 40
    defineWhile    go to state 41


state 249

   90 initOperatorContext: defineType operator defineType ASSIGN . name endls

    NAME  shift, and go to state 1

    name  go to state 257


state 250

  116 subSpace: LBRACE endlsn stat endlsn RBRACE .

    $default  reduce using rule 116 (subSpace)


state 251

   56 defineFor: FOR LPAREN paramList @1 SEMICOLON expr SEMICOLON iteration . RPAREN @2 subSpace

    RPAREN  shift, and go to state 258


state 252

  143 switchStat: CASE LPAREN . expr RPAREN @10 subSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 47
    NUMBER         shift, and go to state 48
    STRING         shift, and go to state 49
    VALUE_BOOLEAN  shift, and go to state 50
    VALUE_VOID     shift, and go to state 51
    RPAREN         shift, and go to state 52
    LPAREN         shift, and go to state 53
    LBRACE         shift, and go to state 54
    LBRACKET       shift, and go to state 55

    name         go to state 56
    arrayExpr    go to state 57
    dictExpr     go to state 58
    expr         go to state 259
    funcExpr     go to state 60
    funcHeaderE  go to state 61
    defineIden   go to state 62
    idenFunc     go to state 63
    idenBracket  go to state 26


state 253

  145 switchStat: DEFAULT @11 . subSpace

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    LPAREN     shift, and go to state 4
    LBRACE     shift, and go to state 168
    RETURN     shift, and go to state 7
    IF         shift, and go to state 8
    FOR        shift, and go to state 9
    WHILE      shift, and go to state 10
    SWITCH     shift, and go to state 11
    BREAK      shift, and go to state 12
    CONTINUE   shift, and go to state 13
    CONST      shift, and go to state 14

    ENDL      [reduce using rule 91 (assignment)]
    $default  reduce using rule 91 (assignment)

    endls          go to state 169
    endc           go to state 16
    name           go to state 17
    arrayType      go to state 19
    dictType       go to state 20
    defineFor      go to state 21
    defineFunc     go to state 22
    funcType       go to state 23
    defineIden     go to state 24
    idenFunc       go to state 25
    idenBracket    go to state 26
    defineIf       go to state 27
    ifPart         go to state 28
    assignment     go to state 30
    iteration      go to state 31
    defineParam    go to state 32
    paramListP     go to state 33
    subSpace       go to state 260
    controlSpace   go to state 34
    stat           go to state 171
    defineStat     go to state 37
    defineSwitch   go to state 38
    defineType     go to state 39
    defineVariale  go to state 40
    defineWhile    go to state 41


state 254

  136 switchSpace: LBRACE switchStats RBRACE .

    $default  reduce using rule 136 (switchSpace)


state 255

  138 switchStats: switchStats switchStat .

    $default  reduce using rule 138 (switchStats)


state 256

   80 elseIfPart: ELSE IF LPAREN expr RPAREN @7 subSpace .

    $default  reduce using rule 80 (elseIfPart)


state 257

   90 initOperatorContext: defineType operator defineType ASSIGN name . endls

    ENDL  shift, and go to state 2

    endls  go to state 261


state 258

   56 defineFor: FOR LPAREN paramList @1 SEMICOLON expr SEMICOLON iteration RPAREN . @2 subSpace

    $default  reduce using rule 55 (@2)

    @2  go to state 262


state 259

   26 expr: expr . AND expr
   27     | expr . OR expr
   28     | expr . EQ expr
   29     | expr . NE expr
   30     | expr . GT expr
   31     | expr . GE expr
   32     | expr . LT expr
   33     | expr . LE expr
   34     | expr . PLUS expr
   35     | expr . MINUS expr
   36     | expr . MULT expr
   37     | expr . DIVIDE expr
   38     | expr . MODULUS expr
  143 switchStat: CASE LPAREN expr . RPAREN @10 subSpace

    OR       shift, and go to state 102
    AND      shift, and go to state 103
    NE       shift, and go to state 104
    EQ       shift, and go to state 105
    GE       shift, and go to state 106
    GT       shift, and go to state 107
    LE       shift, and go to state 108
    LT       shift, and go to state 109
    MINUS    shift, and go to state 110
    PLUS     shift, and go to state 111
    MODULUS  shift, and go to state 112
    DIVIDE   shift, and go to state 113
    MULT     shift, and go to state 114
    RPAREN   shift, and go to state 263


state 260

  145 switchStat: DEFAULT @11 subSpace .

    $default  reduce using rule 145 (switchStat)


state 261

    1 endls: endls . ENDL
   90 initOperatorContext: defineType operator defineType ASSIGN name endls .

    ENDL  shift, and go to state 70

    ENDL      [reduce using rule 90 (initOperatorContext)]
    $default  reduce using rule 90 (initOperatorContext)


state 262

   56 defineFor: FOR LPAREN paramList @1 SEMICOLON expr SEMICOLON iteration RPAREN @2 . subSpace

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    LPAREN     shift, and go to state 4
    LBRACE     shift, and go to state 168
    RETURN     shift, and go to state 7
    IF         shift, and go to state 8
    FOR        shift, and go to state 9
    WHILE      shift, and go to state 10
    SWITCH     shift, and go to state 11
    BREAK      shift, and go to state 12
    CONTINUE   shift, and go to state 13
    CONST      shift, and go to state 14

    NAME       [reduce using rule 91 (assignment)]
    ENDL       [reduce using rule 91 (assignment)]
    SEMICOLON  [reduce using rule 91 (assignment)]
    LPAREN     [reduce using rule 91 (assignment)]
    LBRACE     [reduce using rule 91 (assignment)]
    $default   reduce using rule 91 (assignment)

    endls          go to state 169
    endc           go to state 16
    name           go to state 17
    arrayType      go to state 19
    dictType       go to state 20
    defineFor      go to state 21
    defineFunc     go to state 22
    funcType       go to state 23
    defineIden     go to state 24
    idenFunc       go to state 25
    idenBracket    go to state 26
    defineIf       go to state 27
    ifPart         go to state 28
    assignment     go to state 30
    iteration      go to state 31
    defineParam    go to state 32
    paramListP     go to state 33
    subSpace       go to state 264
    controlSpace   go to state 34
    stat           go to state 171
    defineStat     go to state 37
    defineSwitch   go to state 38
    defineType     go to state 39
    defineVariale  go to state 40
    defineWhile    go to state 41


state 263

  143 switchStat: CASE LPAREN expr RPAREN . @10 subSpace

    $default  reduce using rule 142 (@10)

    @10  go to state 265


state 264

   56 defineFor: FOR LPAREN paramList @1 SEMICOLON expr SEMICOLON iteration RPAREN @2 subSpace .

    $default  reduce using rule 56 (defineFor)


state 265

  143 switchStat: CASE LPAREN expr RPAREN @10 . subSpace

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    LPAREN     shift, and go to state 4
    LBRACE     shift, and go to state 168
    RETURN     shift, and go to state 7
    IF         shift, and go to state 8
    FOR        shift, and go to state 9
    WHILE      shift, and go to state 10
    SWITCH     shift, and go to state 11
    BREAK      shift, and go to state 12
    CONTINUE   shift, and go to state 13
    CONST      shift, and go to state 14

    ENDL      [reduce using rule 91 (assignment)]
    $default  reduce using rule 91 (assignment)

    endls          go to state 169
    endc           go to state 16
    name           go to state 17
    arrayType      go to state 19
    dictType       go to state 20
    defineFor      go to state 21
    defineFunc     go to state 22
    funcType       go to state 23
    defineIden     go to state 24
    idenFunc       go to state 25
    idenBracket    go to state 26
    defineIf       go to state 27
    ifPart         go to state 28
    assignment     go to state 30
    iteration      go to state 31
    defineParam    go to state 32
    paramListP     go to state 33
    subSpace       go to state 266
    controlSpace   go to state 34
    stat           go to state 171
    defineStat     go to state 37
    defineSwitch   go to state 38
    defineType     go to state 39
    defineVariale  go to state 40
    defineWhile    go to state 41


state 266

  143 switchStat: CASE LPAREN expr RPAREN @10 subSpace .

    $default  reduce using rule 143 (switchStat)
