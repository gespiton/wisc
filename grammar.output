State 0 conflicts: 3 shift/reduce, 1 reduce/reduce
State 4 conflicts: 1 shift/reduce
State 13 conflicts: 10 shift/reduce
State 29 conflicts: 12 reduce/reduce
State 47 conflicts: 1 shift/reduce
State 107 conflicts: 3 shift/reduce
State 124 conflicts: 2 reduce/reduce
State 138 conflicts: 3 shift/reduce
State 146 conflicts: 1 shift/reduce
State 147 conflicts: 4 shift/reduce


Grammar

    0 $accept: program $end

    1 endls: endls ENDL
    2      | ENDL

    3 endc: SEMICOLON
    4     | endls

    5 list: COMMA
    6     | list endls

    7 name: NAME

    8 program: /* empty */
    9        | space

   10 expr: STRING
   11     | VALUE_VOID
   12     | VALUE_BOOLEAN
   13     | INT
   14     | NUMBER
   15     | defineIden
   16     | funcExpr

   17 exprList: /* empty */
   18         | exprList list expr
   19         | expr

   20 @1: /* empty */

   21 defineFor: FOR RPAREN paramList @1 SEMICOLON expr SEMICOLON iteration LPAREN subSpace

   22 @2: /* empty */

   23 defineFunc: defineType name funcHeaderV @2 subSpace

   24 @3: /* empty */

   25 funcExpr: funcHeaderE @3 subSpace

   26 funcHeaderV: RPAREN paramList LPAREN

   27 @4: /* empty */

   28 funcHeaderE: RPAREN @4 paramList LPAREN COLON defineType

   29 funcType: defineType COLON RPAREN typeList LPAREN

   30 defineIden: name
   31           | idenFunc

   32 idenFunc: defineIden RPAREN exprList LPAREN

   33 defineIf: ifPart
   34         | ifPart elseIfParts
   35         | ifPart elsePart
   36         | ifPart elseIfParts elsePart

   37 @5: /* empty */

   38 ifPart: IF RPAREN expr LPAREN @5 subSpace

   39 elseIfParts: elseIfParts elseIfPart
   40            | elseIfPart

   41 @6: /* empty */

   42 elseIfPart: ELSE IF RPAREN expr LPAREN @6 subSpace

   43 @7: /* empty */

   44 elsePart: ELSE @7 subSpace

   45 assignment: defineIden ASSIGN expr

   46 iteration: assignment

   47 defineParam: defineType name
   48            | defineType name ASSIGN expr

   49 paramListP: paramListP list defineParam
   50           | defineParam

   51 paramList: /* empty */
   52          | paramListP

   53 subSpace: RBRACE space LBRACE
   54         | endls subSpace

   55 space: defineStats stats

   56 controlSpace: RETURN expr
   57             | RETURN
   58             | BREAK
   59             | CONTINUE

   60 stats: /* empty */
   61      | stats stat
   62      | stat

   63 stat: endc
   64     | iteration endc
   65     | controlSpace endc
   66     | idenFunc endc
   67     | defineIf endc
   68     | defineWhile endc
   69     | defineFor endc
   70     | defineSwitch endc

   71 defineStats: /* empty */
   72            | defineStats defineStat
   73            | defineStat

   74 defineStat: endc
   75           | defineFunc endc
   76           | defineVariale endc

   77 @8: /* empty */

   78 defineSwitch: SWITCH RPAREN expr LPAREN @8 switchSpace

   79 switchSpace: RBRACE switchStats LBRACE
   80            | endls switchSpace

   81 switchStats: switchStats switchStat
   82            | switchStat

   83 switchStat: /* empty */
   84           | endls

   85 @9: /* empty */

   86 switchStat: CASE RPAREN expr LPAREN @9 subSpace

   87 @10: /* empty */

   88 switchStat: DEFAULT @10 subSpace

   89 defineType: name
   90           | funcType

   91 typeListP: typeListP list defineType
   92          | defineType

   93 typeList: /* empty */
   94         | typeListP

   95 defineVariale: paramListP

   96 @11: /* empty */

   97 defineWhile: WHILE RPAREN expr LPAREN @11 subSpace


Terminals, with rules where they appear

$end (0) 0
error (256)
NAME (258) 7
ENDL (259) 1 2
INT (260) 13
NUMBER (261) 14
STRING (262) 10
VALUE_BOOLEAN (263) 12
VALUE_VOID (264) 11
SEMICOLON (265) 3 21
COLON (266) 28 29
ASSIGN (267) 45 48
RPAREN (268) 21 26 28 29 32 38 42 78 86 97
LPAREN (269) 21 26 28 29 32 38 42 78 86 97
RBRACE (270) 53 79
LBRACE (271) 53 79
COMMA (272) 5
RETURN (273) 56 57
IF (274) 38 42
ELSE (275) 42 44
FOR (276) 21
WHILE (277) 97
SWITCH (278) 78
CASE (279) 86
DEFAULT (280) 88
BREAK (281) 58
CONTINUE (282) 59


Nonterminals, with rules where they appear

$accept (28)
    on left: 0
endls (29)
    on left: 1 2, on right: 1 4 6 54 80 84
endc (30)
    on left: 3 4, on right: 63 64 65 66 67 68 69 70 74 75 76
list (31)
    on left: 5 6, on right: 6 18 49 91
name (32)
    on left: 7, on right: 23 30 47 48 89
program (33)
    on left: 8 9, on right: 0
expr (34)
    on left: 10 11 12 13 14 15 16, on right: 18 19 21 38 42 45 48 56
    78 86 97
exprList (35)
    on left: 17 18 19, on right: 18 32
defineFor (36)
    on left: 21, on right: 69
@1 (37)
    on left: 20, on right: 21
defineFunc (38)
    on left: 23, on right: 75
@2 (39)
    on left: 22, on right: 23
funcExpr (40)
    on left: 25, on right: 16
@3 (41)
    on left: 24, on right: 25
funcHeaderV (42)
    on left: 26, on right: 23
funcHeaderE (43)
    on left: 28, on right: 25
@4 (44)
    on left: 27, on right: 28
funcType (45)
    on left: 29, on right: 90
defineIden (46)
    on left: 30 31, on right: 15 32 45
idenFunc (47)
    on left: 32, on right: 31 66
defineIf (48)
    on left: 33 34 35 36, on right: 67
ifPart (49)
    on left: 38, on right: 33 34 35 36
@5 (50)
    on left: 37, on right: 38
elseIfParts (51)
    on left: 39 40, on right: 34 36 39
elseIfPart (52)
    on left: 42, on right: 39 40
@6 (53)
    on left: 41, on right: 42
elsePart (54)
    on left: 44, on right: 35 36
@7 (55)
    on left: 43, on right: 44
assignment (56)
    on left: 45, on right: 46
iteration (57)
    on left: 46, on right: 21 64
defineParam (58)
    on left: 47 48, on right: 49 50
paramListP (59)
    on left: 49 50, on right: 49 52 95
paramList (60)
    on left: 51 52, on right: 21 26 28
subSpace (61)
    on left: 53 54, on right: 21 23 25 38 42 44 54 86 88 97
space (62)
    on left: 55, on right: 9 53
controlSpace (63)
    on left: 56 57 58 59, on right: 65
stats (64)
    on left: 60 61 62, on right: 55 61
stat (65)
    on left: 63 64 65 66 67 68 69 70, on right: 61 62
defineStats (66)
    on left: 71 72 73, on right: 55 72
defineStat (67)
    on left: 74 75 76, on right: 72 73
defineSwitch (68)
    on left: 78, on right: 70
@8 (69)
    on left: 77, on right: 78
switchSpace (70)
    on left: 79 80, on right: 78 80
switchStats (71)
    on left: 81 82, on right: 79 81
switchStat (72)
    on left: 83 84 86 88, on right: 81 82
@9 (73)
    on left: 85, on right: 86
@10 (74)
    on left: 87, on right: 88
defineType (75)
    on left: 89 90, on right: 23 28 29 47 48 91 92
typeListP (76)
    on left: 91 92, on right: 91 94
typeList (77)
    on left: 93 94, on right: 29
defineVariale (78)
    on left: 95, on right: 76
defineWhile (79)
    on left: 97, on right: 68
@11 (80)
    on left: 96, on right: 97


state 0

    0 $accept: . program $end

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    $end       reduce using rule 8 (program)
    $end       [reduce using rule 71 (defineStats)]
    NAME       [reduce using rule 71 (defineStats)]
    ENDL       [reduce using rule 71 (defineStats)]
    SEMICOLON  [reduce using rule 71 (defineStats)]
    $default   reduce using rule 71 (defineStats)

    endls          go to state 4
    endc           go to state 5
    name           go to state 6
    program        go to state 7
    defineFunc     go to state 8
    funcType       go to state 9
    defineParam    go to state 10
    paramListP     go to state 11
    space          go to state 12
    defineStats    go to state 13
    defineStat     go to state 14
    defineType     go to state 15
    defineVariale  go to state 16


state 1

    7 name: NAME .

    $default  reduce using rule 7 (name)


state 2

    2 endls: ENDL .

    $default  reduce using rule 2 (endls)


state 3

    3 endc: SEMICOLON .

    $default  reduce using rule 3 (endc)


state 4

    1 endls: endls . ENDL
    4 endc: endls .

    ENDL  shift, and go to state 17

    ENDL      [reduce using rule 4 (endc)]
    $default  reduce using rule 4 (endc)


state 5

   74 defineStat: endc .

    $default  reduce using rule 74 (defineStat)


state 6

   89 defineType: name .

    $default  reduce using rule 89 (defineType)


state 7

    0 $accept: program . $end

    $end  shift, and go to state 18


state 8

   75 defineStat: defineFunc . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 4
    endc   go to state 19


state 9

   90 defineType: funcType .

    $default  reduce using rule 90 (defineType)


state 10

   50 paramListP: defineParam .

    $default  reduce using rule 50 (paramListP)


state 11

   49 paramListP: paramListP . list defineParam
   95 defineVariale: paramListP .

    COMMA  shift, and go to state 20

    $default  reduce using rule 95 (defineVariale)

    list  go to state 21


state 12

    9 program: space .

    $default  reduce using rule 9 (program)


state 13

   55 space: defineStats . stats
   72 defineStats: defineStats . defineStat

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    RETURN     shift, and go to state 22
    IF         shift, and go to state 23
    FOR        shift, and go to state 24
    WHILE      shift, and go to state 25
    SWITCH     shift, and go to state 26
    BREAK      shift, and go to state 27
    CONTINUE   shift, and go to state 28

    NAME       [reduce using rule 60 (stats)]
    ENDL       [reduce using rule 60 (stats)]
    SEMICOLON  [reduce using rule 60 (stats)]
    RETURN     [reduce using rule 60 (stats)]
    IF         [reduce using rule 60 (stats)]
    FOR        [reduce using rule 60 (stats)]
    WHILE      [reduce using rule 60 (stats)]
    SWITCH     [reduce using rule 60 (stats)]
    BREAK      [reduce using rule 60 (stats)]
    CONTINUE   [reduce using rule 60 (stats)]
    $default   reduce using rule 60 (stats)

    endls          go to state 4
    endc           go to state 29
    name           go to state 30
    defineFor      go to state 31
    defineFunc     go to state 8
    funcType       go to state 9
    defineIden     go to state 32
    idenFunc       go to state 33
    defineIf       go to state 34
    ifPart         go to state 35
    assignment     go to state 36
    iteration      go to state 37
    defineParam    go to state 10
    paramListP     go to state 11
    controlSpace   go to state 38
    stats          go to state 39
    stat           go to state 40
    defineStat     go to state 41
    defineSwitch   go to state 42
    defineType     go to state 15
    defineVariale  go to state 16
    defineWhile    go to state 43


state 14

   73 defineStats: defineStat .

    $default  reduce using rule 73 (defineStats)


state 15

   23 defineFunc: defineType . name funcHeaderV @2 subSpace
   29 funcType: defineType . COLON RPAREN typeList LPAREN
   47 defineParam: defineType . name
   48            | defineType . name ASSIGN expr

    NAME   shift, and go to state 1
    COLON  shift, and go to state 44

    name  go to state 45


state 16

   76 defineStat: defineVariale . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 4
    endc   go to state 46


state 17

    1 endls: endls ENDL .

    $default  reduce using rule 1 (endls)


state 18

    0 $accept: program $end .

    $default  accept


state 19

   75 defineStat: defineFunc endc .

    $default  reduce using rule 75 (defineStat)


state 20

    5 list: COMMA .

    $default  reduce using rule 5 (list)


state 21

    6 list: list . endls
   49 paramListP: paramListP list . defineParam

    NAME  shift, and go to state 1
    ENDL  shift, and go to state 2

    endls        go to state 47
    name         go to state 6
    funcType     go to state 9
    defineParam  go to state 48
    defineType   go to state 49


state 22

   56 controlSpace: RETURN . expr
   57             | RETURN .

    NAME           shift, and go to state 1
    INT            shift, and go to state 50
    NUMBER         shift, and go to state 51
    STRING         shift, and go to state 52
    VALUE_BOOLEAN  shift, and go to state 53
    VALUE_VOID     shift, and go to state 54
    RPAREN         shift, and go to state 55

    $default  reduce using rule 57 (controlSpace)

    name         go to state 56
    expr         go to state 57
    funcExpr     go to state 58
    funcHeaderE  go to state 59
    defineIden   go to state 60
    idenFunc     go to state 61


state 23

   38 ifPart: IF . RPAREN expr LPAREN @5 subSpace

    RPAREN  shift, and go to state 62


state 24

   21 defineFor: FOR . RPAREN paramList @1 SEMICOLON expr SEMICOLON iteration LPAREN subSpace

    RPAREN  shift, and go to state 63


state 25

   97 defineWhile: WHILE . RPAREN expr LPAREN @11 subSpace

    RPAREN  shift, and go to state 64


state 26

   78 defineSwitch: SWITCH . RPAREN expr LPAREN @8 switchSpace

    RPAREN  shift, and go to state 65


state 27

   58 controlSpace: BREAK .

    $default  reduce using rule 58 (controlSpace)


state 28

   59 controlSpace: CONTINUE .

    $default  reduce using rule 59 (controlSpace)


state 29

   63 stat: endc .
   74 defineStat: endc .

    $end       reduce using rule 63 (stat)
    $end       [reduce using rule 74 (defineStat)]
    NAME       reduce using rule 63 (stat)
    NAME       [reduce using rule 74 (defineStat)]
    ENDL       reduce using rule 63 (stat)
    ENDL       [reduce using rule 74 (defineStat)]
    SEMICOLON  reduce using rule 63 (stat)
    SEMICOLON  [reduce using rule 74 (defineStat)]
    LBRACE     reduce using rule 63 (stat)
    LBRACE     [reduce using rule 74 (defineStat)]
    RETURN     reduce using rule 63 (stat)
    RETURN     [reduce using rule 74 (defineStat)]
    IF         reduce using rule 63 (stat)
    IF         [reduce using rule 74 (defineStat)]
    FOR        reduce using rule 63 (stat)
    FOR        [reduce using rule 74 (defineStat)]
    WHILE      reduce using rule 63 (stat)
    WHILE      [reduce using rule 74 (defineStat)]
    SWITCH     reduce using rule 63 (stat)
    SWITCH     [reduce using rule 74 (defineStat)]
    BREAK      reduce using rule 63 (stat)
    BREAK      [reduce using rule 74 (defineStat)]
    CONTINUE   reduce using rule 63 (stat)
    CONTINUE   [reduce using rule 74 (defineStat)]
    $default   reduce using rule 63 (stat)


state 30

   30 defineIden: name .
   89 defineType: name .

    NAME      reduce using rule 89 (defineType)
    COLON     reduce using rule 89 (defineType)
    $default  reduce using rule 30 (defineIden)


state 31

   69 stat: defineFor . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 4
    endc   go to state 66


state 32

   32 idenFunc: defineIden . RPAREN exprList LPAREN
   45 assignment: defineIden . ASSIGN expr

    ASSIGN  shift, and go to state 67
    RPAREN  shift, and go to state 68


state 33

   31 defineIden: idenFunc .
   66 stat: idenFunc . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    $default  reduce using rule 31 (defineIden)

    endls  go to state 4
    endc   go to state 69


state 34

   67 stat: defineIf . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 4
    endc   go to state 70


state 35

   33 defineIf: ifPart .
   34         | ifPart . elseIfParts
   35         | ifPart . elsePart
   36         | ifPart . elseIfParts elsePart

    ELSE  shift, and go to state 71

    $default  reduce using rule 33 (defineIf)

    elseIfParts  go to state 72
    elseIfPart   go to state 73
    elsePart     go to state 74


state 36

   46 iteration: assignment .

    $default  reduce using rule 46 (iteration)


state 37

   64 stat: iteration . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 4
    endc   go to state 75


state 38

   65 stat: controlSpace . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 4
    endc   go to state 76


state 39

   55 space: defineStats stats .
   61 stats: stats . stat

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    RETURN     shift, and go to state 22
    IF         shift, and go to state 23
    FOR        shift, and go to state 24
    WHILE      shift, and go to state 25
    SWITCH     shift, and go to state 26
    BREAK      shift, and go to state 27
    CONTINUE   shift, and go to state 28

    $default  reduce using rule 55 (space)

    endls         go to state 4
    endc          go to state 77
    name          go to state 56
    defineFor     go to state 31
    defineIden    go to state 32
    idenFunc      go to state 33
    defineIf      go to state 34
    ifPart        go to state 35
    assignment    go to state 36
    iteration     go to state 37
    controlSpace  go to state 38
    stat          go to state 78
    defineSwitch  go to state 42
    defineWhile   go to state 43


state 40

   62 stats: stat .

    $default  reduce using rule 62 (stats)


state 41

   72 defineStats: defineStats defineStat .

    $default  reduce using rule 72 (defineStats)


state 42

   70 stat: defineSwitch . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 4
    endc   go to state 79


state 43

   68 stat: defineWhile . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 4
    endc   go to state 80


state 44

   29 funcType: defineType COLON . RPAREN typeList LPAREN

    RPAREN  shift, and go to state 81


state 45

   23 defineFunc: defineType name . funcHeaderV @2 subSpace
   47 defineParam: defineType name .
   48            | defineType name . ASSIGN expr

    ASSIGN  shift, and go to state 82
    RPAREN  shift, and go to state 83

    $default  reduce using rule 47 (defineParam)

    funcHeaderV  go to state 84


state 46

   76 defineStat: defineVariale endc .

    $default  reduce using rule 76 (defineStat)


state 47

    1 endls: endls . ENDL
    6 list: list endls .

    ENDL  shift, and go to state 17

    ENDL      [reduce using rule 6 (list)]
    $default  reduce using rule 6 (list)


state 48

   49 paramListP: paramListP list defineParam .

    $default  reduce using rule 49 (paramListP)


state 49

   29 funcType: defineType . COLON RPAREN typeList LPAREN
   47 defineParam: defineType . name
   48            | defineType . name ASSIGN expr

    NAME   shift, and go to state 1
    COLON  shift, and go to state 44

    name  go to state 85


state 50

   13 expr: INT .

    $default  reduce using rule 13 (expr)


state 51

   14 expr: NUMBER .

    $default  reduce using rule 14 (expr)


state 52

   10 expr: STRING .

    $default  reduce using rule 10 (expr)


state 53

   12 expr: VALUE_BOOLEAN .

    $default  reduce using rule 12 (expr)


state 54

   11 expr: VALUE_VOID .

    $default  reduce using rule 11 (expr)


state 55

   28 funcHeaderE: RPAREN . @4 paramList LPAREN COLON defineType

    $default  reduce using rule 27 (@4)

    @4  go to state 86


state 56

   30 defineIden: name .

    $default  reduce using rule 30 (defineIden)


state 57

   56 controlSpace: RETURN expr .

    $default  reduce using rule 56 (controlSpace)


state 58

   16 expr: funcExpr .

    $default  reduce using rule 16 (expr)


state 59

   25 funcExpr: funcHeaderE . @3 subSpace

    $default  reduce using rule 24 (@3)

    @3  go to state 87


state 60

   15 expr: defineIden .
   32 idenFunc: defineIden . RPAREN exprList LPAREN

    RPAREN  shift, and go to state 68

    $default  reduce using rule 15 (expr)


state 61

   31 defineIden: idenFunc .

    $default  reduce using rule 31 (defineIden)


state 62

   38 ifPart: IF RPAREN . expr LPAREN @5 subSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 50
    NUMBER         shift, and go to state 51
    STRING         shift, and go to state 52
    VALUE_BOOLEAN  shift, and go to state 53
    VALUE_VOID     shift, and go to state 54
    RPAREN         shift, and go to state 55

    name         go to state 56
    expr         go to state 88
    funcExpr     go to state 58
    funcHeaderE  go to state 59
    defineIden   go to state 60
    idenFunc     go to state 61


state 63

   21 defineFor: FOR RPAREN . paramList @1 SEMICOLON expr SEMICOLON iteration LPAREN subSpace

    NAME  shift, and go to state 1

    $default  reduce using rule 51 (paramList)

    name         go to state 6
    funcType     go to state 9
    defineParam  go to state 10
    paramListP   go to state 89
    paramList    go to state 90
    defineType   go to state 49


state 64

   97 defineWhile: WHILE RPAREN . expr LPAREN @11 subSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 50
    NUMBER         shift, and go to state 51
    STRING         shift, and go to state 52
    VALUE_BOOLEAN  shift, and go to state 53
    VALUE_VOID     shift, and go to state 54
    RPAREN         shift, and go to state 55

    name         go to state 56
    expr         go to state 91
    funcExpr     go to state 58
    funcHeaderE  go to state 59
    defineIden   go to state 60
    idenFunc     go to state 61


state 65

   78 defineSwitch: SWITCH RPAREN . expr LPAREN @8 switchSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 50
    NUMBER         shift, and go to state 51
    STRING         shift, and go to state 52
    VALUE_BOOLEAN  shift, and go to state 53
    VALUE_VOID     shift, and go to state 54
    RPAREN         shift, and go to state 55

    name         go to state 56
    expr         go to state 92
    funcExpr     go to state 58
    funcHeaderE  go to state 59
    defineIden   go to state 60
    idenFunc     go to state 61


state 66

   69 stat: defineFor endc .

    $default  reduce using rule 69 (stat)


state 67

   45 assignment: defineIden ASSIGN . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 50
    NUMBER         shift, and go to state 51
    STRING         shift, and go to state 52
    VALUE_BOOLEAN  shift, and go to state 53
    VALUE_VOID     shift, and go to state 54
    RPAREN         shift, and go to state 55

    name         go to state 56
    expr         go to state 93
    funcExpr     go to state 58
    funcHeaderE  go to state 59
    defineIden   go to state 60
    idenFunc     go to state 61


state 68

   32 idenFunc: defineIden RPAREN . exprList LPAREN

    NAME           shift, and go to state 1
    INT            shift, and go to state 50
    NUMBER         shift, and go to state 51
    STRING         shift, and go to state 52
    VALUE_BOOLEAN  shift, and go to state 53
    VALUE_VOID     shift, and go to state 54
    RPAREN         shift, and go to state 55

    $default  reduce using rule 17 (exprList)

    name         go to state 56
    expr         go to state 94
    exprList     go to state 95
    funcExpr     go to state 58
    funcHeaderE  go to state 59
    defineIden   go to state 60
    idenFunc     go to state 61


state 69

   66 stat: idenFunc endc .

    $default  reduce using rule 66 (stat)


state 70

   67 stat: defineIf endc .

    $default  reduce using rule 67 (stat)


state 71

   42 elseIfPart: ELSE . IF RPAREN expr LPAREN @6 subSpace
   44 elsePart: ELSE . @7 subSpace

    IF  shift, and go to state 96

    $default  reduce using rule 43 (@7)

    @7  go to state 97


state 72

   34 defineIf: ifPart elseIfParts .
   36         | ifPart elseIfParts . elsePart
   39 elseIfParts: elseIfParts . elseIfPart

    ELSE  shift, and go to state 71

    $default  reduce using rule 34 (defineIf)

    elseIfPart  go to state 98
    elsePart    go to state 99


state 73

   40 elseIfParts: elseIfPart .

    $default  reduce using rule 40 (elseIfParts)


state 74

   35 defineIf: ifPart elsePart .

    $default  reduce using rule 35 (defineIf)


state 75

   64 stat: iteration endc .

    $default  reduce using rule 64 (stat)


state 76

   65 stat: controlSpace endc .

    $default  reduce using rule 65 (stat)


state 77

   63 stat: endc .

    $default  reduce using rule 63 (stat)


state 78

   61 stats: stats stat .

    $default  reduce using rule 61 (stats)


state 79

   70 stat: defineSwitch endc .

    $default  reduce using rule 70 (stat)


state 80

   68 stat: defineWhile endc .

    $default  reduce using rule 68 (stat)


state 81

   29 funcType: defineType COLON RPAREN . typeList LPAREN

    NAME  shift, and go to state 1

    $default  reduce using rule 93 (typeList)

    name        go to state 6
    funcType    go to state 9
    defineType  go to state 100
    typeListP   go to state 101
    typeList    go to state 102


state 82

   48 defineParam: defineType name ASSIGN . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 50
    NUMBER         shift, and go to state 51
    STRING         shift, and go to state 52
    VALUE_BOOLEAN  shift, and go to state 53
    VALUE_VOID     shift, and go to state 54
    RPAREN         shift, and go to state 55

    name         go to state 56
    expr         go to state 103
    funcExpr     go to state 58
    funcHeaderE  go to state 59
    defineIden   go to state 60
    idenFunc     go to state 61


state 83

   26 funcHeaderV: RPAREN . paramList LPAREN

    NAME  shift, and go to state 1

    $default  reduce using rule 51 (paramList)

    name         go to state 6
    funcType     go to state 9
    defineParam  go to state 10
    paramListP   go to state 89
    paramList    go to state 104
    defineType   go to state 49


state 84

   23 defineFunc: defineType name funcHeaderV . @2 subSpace

    $default  reduce using rule 22 (@2)

    @2  go to state 105


state 85

   47 defineParam: defineType name .
   48            | defineType name . ASSIGN expr

    ASSIGN  shift, and go to state 82

    $default  reduce using rule 47 (defineParam)


state 86

   28 funcHeaderE: RPAREN @4 . paramList LPAREN COLON defineType

    NAME  shift, and go to state 1

    $default  reduce using rule 51 (paramList)

    name         go to state 6
    funcType     go to state 9
    defineParam  go to state 10
    paramListP   go to state 89
    paramList    go to state 106
    defineType   go to state 49


state 87

   25 funcExpr: funcHeaderE @3 . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 107

    endls     go to state 108
    subSpace  go to state 109


state 88

   38 ifPart: IF RPAREN expr . LPAREN @5 subSpace

    LPAREN  shift, and go to state 110


state 89

   49 paramListP: paramListP . list defineParam
   52 paramList: paramListP .

    COMMA  shift, and go to state 20

    $default  reduce using rule 52 (paramList)

    list  go to state 21


state 90

   21 defineFor: FOR RPAREN paramList . @1 SEMICOLON expr SEMICOLON iteration LPAREN subSpace

    $default  reduce using rule 20 (@1)

    @1  go to state 111


state 91

   97 defineWhile: WHILE RPAREN expr . LPAREN @11 subSpace

    LPAREN  shift, and go to state 112


state 92

   78 defineSwitch: SWITCH RPAREN expr . LPAREN @8 switchSpace

    LPAREN  shift, and go to state 113


state 93

   45 assignment: defineIden ASSIGN expr .

    $default  reduce using rule 45 (assignment)


state 94

   19 exprList: expr .

    $default  reduce using rule 19 (exprList)


state 95

   18 exprList: exprList . list expr
   32 idenFunc: defineIden RPAREN exprList . LPAREN

    LPAREN  shift, and go to state 114
    COMMA   shift, and go to state 20

    list  go to state 115


state 96

   42 elseIfPart: ELSE IF . RPAREN expr LPAREN @6 subSpace

    RPAREN  shift, and go to state 116


state 97

   44 elsePart: ELSE @7 . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 107

    endls     go to state 108
    subSpace  go to state 117


state 98

   39 elseIfParts: elseIfParts elseIfPart .

    $default  reduce using rule 39 (elseIfParts)


state 99

   36 defineIf: ifPart elseIfParts elsePart .

    $default  reduce using rule 36 (defineIf)


state 100

   29 funcType: defineType . COLON RPAREN typeList LPAREN
   92 typeListP: defineType .

    COLON  shift, and go to state 44

    $default  reduce using rule 92 (typeListP)


state 101

   91 typeListP: typeListP . list defineType
   94 typeList: typeListP .

    COMMA  shift, and go to state 20

    $default  reduce using rule 94 (typeList)

    list  go to state 118


state 102

   29 funcType: defineType COLON RPAREN typeList . LPAREN

    LPAREN  shift, and go to state 119


state 103

   48 defineParam: defineType name ASSIGN expr .

    $default  reduce using rule 48 (defineParam)


state 104

   26 funcHeaderV: RPAREN paramList . LPAREN

    LPAREN  shift, and go to state 120


state 105

   23 defineFunc: defineType name funcHeaderV @2 . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 107

    endls     go to state 108
    subSpace  go to state 121


state 106

   28 funcHeaderE: RPAREN @4 paramList . LPAREN COLON defineType

    LPAREN  shift, and go to state 122


state 107

   53 subSpace: RBRACE . space LBRACE

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    NAME       [reduce using rule 71 (defineStats)]
    ENDL       [reduce using rule 71 (defineStats)]
    SEMICOLON  [reduce using rule 71 (defineStats)]
    $default   reduce using rule 71 (defineStats)

    endls          go to state 4
    endc           go to state 5
    name           go to state 6
    defineFunc     go to state 8
    funcType       go to state 9
    defineParam    go to state 10
    paramListP     go to state 11
    space          go to state 123
    defineStats    go to state 13
    defineStat     go to state 14
    defineType     go to state 15
    defineVariale  go to state 16


state 108

    1 endls: endls . ENDL
   54 subSpace: endls . subSpace

    ENDL    shift, and go to state 124
    RBRACE  shift, and go to state 107

    endls     go to state 108
    subSpace  go to state 125


state 109

   25 funcExpr: funcHeaderE @3 subSpace .

    $default  reduce using rule 25 (funcExpr)


state 110

   38 ifPart: IF RPAREN expr LPAREN . @5 subSpace

    $default  reduce using rule 37 (@5)

    @5  go to state 126


state 111

   21 defineFor: FOR RPAREN paramList @1 . SEMICOLON expr SEMICOLON iteration LPAREN subSpace

    SEMICOLON  shift, and go to state 127


state 112

   97 defineWhile: WHILE RPAREN expr LPAREN . @11 subSpace

    $default  reduce using rule 96 (@11)

    @11  go to state 128


state 113

   78 defineSwitch: SWITCH RPAREN expr LPAREN . @8 switchSpace

    $default  reduce using rule 77 (@8)

    @8  go to state 129


state 114

   32 idenFunc: defineIden RPAREN exprList LPAREN .

    $default  reduce using rule 32 (idenFunc)


state 115

    6 list: list . endls
   18 exprList: exprList list . expr

    NAME           shift, and go to state 1
    ENDL           shift, and go to state 2
    INT            shift, and go to state 50
    NUMBER         shift, and go to state 51
    STRING         shift, and go to state 52
    VALUE_BOOLEAN  shift, and go to state 53
    VALUE_VOID     shift, and go to state 54
    RPAREN         shift, and go to state 55

    endls        go to state 47
    name         go to state 56
    expr         go to state 130
    funcExpr     go to state 58
    funcHeaderE  go to state 59
    defineIden   go to state 60
    idenFunc     go to state 61


state 116

   42 elseIfPart: ELSE IF RPAREN . expr LPAREN @6 subSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 50
    NUMBER         shift, and go to state 51
    STRING         shift, and go to state 52
    VALUE_BOOLEAN  shift, and go to state 53
    VALUE_VOID     shift, and go to state 54
    RPAREN         shift, and go to state 55

    name         go to state 56
    expr         go to state 131
    funcExpr     go to state 58
    funcHeaderE  go to state 59
    defineIden   go to state 60
    idenFunc     go to state 61


state 117

   44 elsePart: ELSE @7 subSpace .

    $default  reduce using rule 44 (elsePart)


state 118

    6 list: list . endls
   91 typeListP: typeListP list . defineType

    NAME  shift, and go to state 1
    ENDL  shift, and go to state 2

    endls       go to state 47
    name        go to state 6
    funcType    go to state 9
    defineType  go to state 132


state 119

   29 funcType: defineType COLON RPAREN typeList LPAREN .

    $default  reduce using rule 29 (funcType)


state 120

   26 funcHeaderV: RPAREN paramList LPAREN .

    $default  reduce using rule 26 (funcHeaderV)


state 121

   23 defineFunc: defineType name funcHeaderV @2 subSpace .

    $default  reduce using rule 23 (defineFunc)


state 122

   28 funcHeaderE: RPAREN @4 paramList LPAREN . COLON defineType

    COLON  shift, and go to state 133


state 123

   53 subSpace: RBRACE space . LBRACE

    LBRACE  shift, and go to state 134


state 124

    1 endls: endls ENDL .
    2      | ENDL .

    ENDL      reduce using rule 1 (endls)
    ENDL      [reduce using rule 2 (endls)]
    RBRACE    reduce using rule 1 (endls)
    RBRACE    [reduce using rule 2 (endls)]
    $default  reduce using rule 1 (endls)


state 125

   54 subSpace: endls subSpace .

    $default  reduce using rule 54 (subSpace)


state 126

   38 ifPart: IF RPAREN expr LPAREN @5 . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 107

    endls     go to state 108
    subSpace  go to state 135


state 127

   21 defineFor: FOR RPAREN paramList @1 SEMICOLON . expr SEMICOLON iteration LPAREN subSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 50
    NUMBER         shift, and go to state 51
    STRING         shift, and go to state 52
    VALUE_BOOLEAN  shift, and go to state 53
    VALUE_VOID     shift, and go to state 54
    RPAREN         shift, and go to state 55

    name         go to state 56
    expr         go to state 136
    funcExpr     go to state 58
    funcHeaderE  go to state 59
    defineIden   go to state 60
    idenFunc     go to state 61


state 128

   97 defineWhile: WHILE RPAREN expr LPAREN @11 . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 107

    endls     go to state 108
    subSpace  go to state 137


state 129

   78 defineSwitch: SWITCH RPAREN expr LPAREN @8 . switchSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 138

    endls        go to state 139
    switchSpace  go to state 140


state 130

   18 exprList: exprList list expr .

    $default  reduce using rule 18 (exprList)


state 131

   42 elseIfPart: ELSE IF RPAREN expr . LPAREN @6 subSpace

    LPAREN  shift, and go to state 141


state 132

   29 funcType: defineType . COLON RPAREN typeList LPAREN
   91 typeListP: typeListP list defineType .

    COLON  shift, and go to state 44

    $default  reduce using rule 91 (typeListP)


state 133

   28 funcHeaderE: RPAREN @4 paramList LPAREN COLON . defineType

    NAME  shift, and go to state 1

    name        go to state 6
    funcType    go to state 9
    defineType  go to state 142


state 134

   53 subSpace: RBRACE space LBRACE .

    $default  reduce using rule 53 (subSpace)


state 135

   38 ifPart: IF RPAREN expr LPAREN @5 subSpace .

    $default  reduce using rule 38 (ifPart)


state 136

   21 defineFor: FOR RPAREN paramList @1 SEMICOLON expr . SEMICOLON iteration LPAREN subSpace

    SEMICOLON  shift, and go to state 143


state 137

   97 defineWhile: WHILE RPAREN expr LPAREN @11 subSpace .

    $default  reduce using rule 97 (defineWhile)


state 138

   79 switchSpace: RBRACE . switchStats LBRACE

    ENDL     shift, and go to state 2
    CASE     shift, and go to state 144
    DEFAULT  shift, and go to state 145

    ENDL      [reduce using rule 83 (switchStat)]
    CASE      [reduce using rule 83 (switchStat)]
    DEFAULT   [reduce using rule 83 (switchStat)]
    $default  reduce using rule 83 (switchStat)

    endls        go to state 146
    switchStats  go to state 147
    switchStat   go to state 148


state 139

    1 endls: endls . ENDL
   80 switchSpace: endls . switchSpace

    ENDL    shift, and go to state 124
    RBRACE  shift, and go to state 138

    endls        go to state 139
    switchSpace  go to state 149


state 140

   78 defineSwitch: SWITCH RPAREN expr LPAREN @8 switchSpace .

    $default  reduce using rule 78 (defineSwitch)


state 141

   42 elseIfPart: ELSE IF RPAREN expr LPAREN . @6 subSpace

    $default  reduce using rule 41 (@6)

    @6  go to state 150


state 142

   28 funcHeaderE: RPAREN @4 paramList LPAREN COLON defineType .
   29 funcType: defineType . COLON RPAREN typeList LPAREN

    COLON  shift, and go to state 44

    $default  reduce using rule 28 (funcHeaderE)


state 143

   21 defineFor: FOR RPAREN paramList @1 SEMICOLON expr SEMICOLON . iteration LPAREN subSpace

    NAME  shift, and go to state 1

    name        go to state 56
    defineIden  go to state 32
    idenFunc    go to state 61
    assignment  go to state 36
    iteration   go to state 151


state 144

   86 switchStat: CASE . RPAREN expr LPAREN @9 subSpace

    RPAREN  shift, and go to state 152


state 145

   88 switchStat: DEFAULT . @10 subSpace

    $default  reduce using rule 87 (@10)

    @10  go to state 153


state 146

    1 endls: endls . ENDL
   84 switchStat: endls .

    ENDL  shift, and go to state 17

    ENDL      [reduce using rule 84 (switchStat)]
    $default  reduce using rule 84 (switchStat)


state 147

   79 switchSpace: RBRACE switchStats . LBRACE
   81 switchStats: switchStats . switchStat

    ENDL     shift, and go to state 2
    LBRACE   shift, and go to state 154
    CASE     shift, and go to state 144
    DEFAULT  shift, and go to state 145

    ENDL     [reduce using rule 83 (switchStat)]
    LBRACE   [reduce using rule 83 (switchStat)]
    CASE     [reduce using rule 83 (switchStat)]
    DEFAULT  [reduce using rule 83 (switchStat)]

    endls       go to state 146
    switchStat  go to state 155


state 148

   82 switchStats: switchStat .

    $default  reduce using rule 82 (switchStats)


state 149

   80 switchSpace: endls switchSpace .

    $default  reduce using rule 80 (switchSpace)


state 150

   42 elseIfPart: ELSE IF RPAREN expr LPAREN @6 . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 107

    endls     go to state 108
    subSpace  go to state 156


state 151

   21 defineFor: FOR RPAREN paramList @1 SEMICOLON expr SEMICOLON iteration . LPAREN subSpace

    LPAREN  shift, and go to state 157


state 152

   86 switchStat: CASE RPAREN . expr LPAREN @9 subSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 50
    NUMBER         shift, and go to state 51
    STRING         shift, and go to state 52
    VALUE_BOOLEAN  shift, and go to state 53
    VALUE_VOID     shift, and go to state 54
    RPAREN         shift, and go to state 55

    name         go to state 56
    expr         go to state 158
    funcExpr     go to state 58
    funcHeaderE  go to state 59
    defineIden   go to state 60
    idenFunc     go to state 61


state 153

   88 switchStat: DEFAULT @10 . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 107

    endls     go to state 108
    subSpace  go to state 159


state 154

   79 switchSpace: RBRACE switchStats LBRACE .

    $default  reduce using rule 79 (switchSpace)


state 155

   81 switchStats: switchStats switchStat .

    $default  reduce using rule 81 (switchStats)


state 156

   42 elseIfPart: ELSE IF RPAREN expr LPAREN @6 subSpace .

    $default  reduce using rule 42 (elseIfPart)


state 157

   21 defineFor: FOR RPAREN paramList @1 SEMICOLON expr SEMICOLON iteration LPAREN . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 107

    endls     go to state 108
    subSpace  go to state 160


state 158

   86 switchStat: CASE RPAREN expr . LPAREN @9 subSpace

    LPAREN  shift, and go to state 161


state 159

   88 switchStat: DEFAULT @10 subSpace .

    $default  reduce using rule 88 (switchStat)


state 160

   21 defineFor: FOR RPAREN paramList @1 SEMICOLON expr SEMICOLON iteration LPAREN subSpace .

    $default  reduce using rule 21 (defineFor)


state 161

   86 switchStat: CASE RPAREN expr LPAREN . @9 subSpace

    $default  reduce using rule 85 (@9)

    @9  go to state 162


state 162

   86 switchStat: CASE RPAREN expr LPAREN @9 . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 107

    endls     go to state 108
    subSpace  go to state 163


state 163

   86 switchStat: CASE RPAREN expr LPAREN @9 subSpace .

    $default  reduce using rule 86 (switchStat)
