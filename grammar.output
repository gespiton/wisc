Terminals which are not used

   EPLUS
   DPLUS
   EMINUS
   DMINUS
   EMULT
   EDIVIDE
   EMODULUS
   OR
   AND
   OPPOSITE


State 0 conflicts: 3 shift/reduce, 1 reduce/reduce
State 5 conflicts: 1 shift/reduce
State 15 conflicts: 10 shift/reduce
State 32 conflicts: 12 reduce/reduce
State 53 conflicts: 1 shift/reduce
State 119 conflicts: 1 shift/reduce
State 130 conflicts: 3 shift/reduce
State 155 conflicts: 2 reduce/reduce
State 171 conflicts: 3 shift/reduce
State 180 conflicts: 1 shift/reduce
State 181 conflicts: 4 shift/reduce
State 192 conflicts: 1 shift/reduce


Grammar

    0 $accept: program $end

    1 endls: endls ENDL
    2      | ENDL

    3 endc: SEMICOLON
    4     | endls

    5 list: COMMA
    6     | list endls

    7 name: NAME

    8 program: /* empty */
    9        | init
   10        | space

   11 expr: expr PLUS expr
   12     | expr MINUS expr
   13     | expr MULT expr
   14     | expr DIVIDE expr
   15     | expr MODULUS expr
   16     | STRING
   17     | VALUE_VOID
   18     | VALUE_BOOLEAN
   19     | INT
   20     | NUMBER
   21     | defineIden
   22     | funcExpr

   23 exprList: /* empty */
   24         | exprList list expr
   25         | expr

   26 @1: /* empty */

   27 defineFor: FOR RPAREN paramList @1 SEMICOLON expr SEMICOLON iteration LPAREN subSpace

   28 @2: /* empty */

   29 defineFunc: defineType name funcHeaderV @2 subSpace

   30 @3: /* empty */

   31 funcExpr: funcHeaderE @3 subSpace

   32 funcHeaderV: RPAREN paramList LPAREN

   33 @4: /* empty */

   34 funcHeaderE: RPAREN @4 paramList LPAREN COLON defineType

   35 funcType: defineType COLON RPAREN typeList LPAREN

   36 defineIden: name
   37           | idenFunc

   38 idenFunc: defineIden RPAREN exprList LPAREN

   39 defineIf: ifPart
   40         | ifPart elseIfParts
   41         | ifPart elsePart
   42         | ifPart elseIfParts elsePart

   43 @5: /* empty */

   44 ifPart: IF RPAREN expr LPAREN @5 subSpace

   45 elseIfParts: elseIfParts elseIfPart
   46            | elseIfPart

   47 @6: /* empty */

   48 elseIfPart: ELSE IF RPAREN expr LPAREN @6 subSpace

   49 @7: /* empty */

   50 elsePart: ELSE @7 subSpace

   51 init: DINIT endls initContext DEND endls

   52 initContext: initOperator

   53 initOperator: OPERATOR RBRACE initOperatorContexts LBRACE endls

   54 initOperatorContexts: initOperatorContexts initOperatorContext
   55                     | initOperatorContext

   56 initOperatorContext: endls
   57                    | defineType operator defineType ASSIGN name endls

   58 assignment: defineIden ASSIGN expr

   59 iteration: assignment

   60 operator: PLUS
   61         | MINUS
   62         | MULT
   63         | DIVIDE
   64         | MODULUS

   65 defineParam: defineType name
   66            | defineType name ASSIGN expr

   67 paramListP: paramListP list defineParam
   68           | defineParam

   69 paramList: /* empty */
   70          | paramListP

   71 subSpace: RBRACE space LBRACE
   72         | endls subSpace

   73 space: defineStats stats

   74 controlSpace: RETURN expr
   75             | RETURN
   76             | BREAK
   77             | CONTINUE

   78 stats: /* empty */
   79      | stats stat
   80      | stat

   81 stat: endc
   82     | iteration endc
   83     | controlSpace endc
   84     | idenFunc endc
   85     | defineIf endc
   86     | defineWhile endc
   87     | defineFor endc
   88     | defineSwitch endc

   89 defineStats: /* empty */
   90            | defineStats defineStat
   91            | defineStat

   92 defineStat: endc
   93           | defineFunc endc
   94           | defineVariale endc

   95 @8: /* empty */

   96 defineSwitch: SWITCH RPAREN expr LPAREN @8 switchSpace

   97 switchSpace: RBRACE switchStats LBRACE
   98            | endls switchSpace

   99 switchStats: switchStats switchStat
  100            | switchStat

  101 switchStat: /* empty */
  102           | endls

  103 @9: /* empty */

  104 switchStat: CASE RPAREN expr LPAREN @9 subSpace

  105 @10: /* empty */

  106 switchStat: DEFAULT @10 subSpace

  107 defineType: name
  108           | funcType

  109 typeListP: typeListP list defineType
  110          | defineType

  111 typeList: /* empty */
  112         | typeListP

  113 defineVariale: paramListP

  114 @11: /* empty */

  115 defineWhile: WHILE RPAREN expr LPAREN @11 subSpace


Terminals, with rules where they appear

$end (0) 0
error (256)
MINUS (258) 12 61
PLUS (259) 11 60
MODULUS (260) 15 64
DIVIDE (261) 14 63
MULT (262) 13 62
NAME (263) 7
ENDL (264) 1 2
INT (265) 19
NUMBER (266) 20
STRING (267) 16
VALUE_BOOLEAN (268) 18
VALUE_VOID (269) 17
SEMICOLON (270) 3 27
COLON (271) 34 35
ASSIGN (272) 57 58 66
RPAREN (273) 27 32 34 35 38 44 48 96 104 115
LPAREN (274) 27 32 34 35 38 44 48 96 104 115
RBRACE (275) 53 71 97
LBRACE (276) 53 71 97
COMMA (277) 5
DINIT (278) 51
DEND (279) 51
RETURN (280) 74 75
IF (281) 44 48
ELSE (282) 48 50
FOR (283) 27
WHILE (284) 115
SWITCH (285) 96
CASE (286) 104
DEFAULT (287) 106
BREAK (288) 76
CONTINUE (289) 77
OPERATOR (290) 53
EPLUS (291)
DPLUS (292)
EMINUS (293)
DMINUS (294)
EMULT (295)
EDIVIDE (296)
EMODULUS (297)
OR (298)
AND (299)
OPPOSITE (300)


Nonterminals, with rules where they appear

$accept (46)
    on left: 0
endls (47)
    on left: 1 2, on right: 1 4 6 51 53 56 57 72 98 102
endc (48)
    on left: 3 4, on right: 81 82 83 84 85 86 87 88 92 93 94
list (49)
    on left: 5 6, on right: 6 24 67 109
name (50)
    on left: 7, on right: 29 36 57 65 66 107
program (51)
    on left: 8 9 10, on right: 0
expr (52)
    on left: 11 12 13 14 15 16 17 18 19 20 21 22, on right: 11 12 13
    14 15 24 25 27 44 48 58 66 74 96 104 115
exprList (53)
    on left: 23 24 25, on right: 24 38
defineFor (54)
    on left: 27, on right: 87
@1 (55)
    on left: 26, on right: 27
defineFunc (56)
    on left: 29, on right: 93
@2 (57)
    on left: 28, on right: 29
funcExpr (58)
    on left: 31, on right: 22
@3 (59)
    on left: 30, on right: 31
funcHeaderV (60)
    on left: 32, on right: 29
funcHeaderE (61)
    on left: 34, on right: 31
@4 (62)
    on left: 33, on right: 34
funcType (63)
    on left: 35, on right: 108
defineIden (64)
    on left: 36 37, on right: 21 38 58
idenFunc (65)
    on left: 38, on right: 37 84
defineIf (66)
    on left: 39 40 41 42, on right: 85
ifPart (67)
    on left: 44, on right: 39 40 41 42
@5 (68)
    on left: 43, on right: 44
elseIfParts (69)
    on left: 45 46, on right: 40 42 45
elseIfPart (70)
    on left: 48, on right: 45 46
@6 (71)
    on left: 47, on right: 48
elsePart (72)
    on left: 50, on right: 41 42
@7 (73)
    on left: 49, on right: 50
init (74)
    on left: 51, on right: 9
initContext (75)
    on left: 52, on right: 51
initOperator (76)
    on left: 53, on right: 52
initOperatorContexts (77)
    on left: 54 55, on right: 53 54
initOperatorContext (78)
    on left: 56 57, on right: 54 55
assignment (79)
    on left: 58, on right: 59
iteration (80)
    on left: 59, on right: 27 82
operator (81)
    on left: 60 61 62 63 64, on right: 57
defineParam (82)
    on left: 65 66, on right: 67 68
paramListP (83)
    on left: 67 68, on right: 67 70 113
paramList (84)
    on left: 69 70, on right: 27 32 34
subSpace (85)
    on left: 71 72, on right: 27 29 31 44 48 50 72 104 106 115
space (86)
    on left: 73, on right: 10 71
controlSpace (87)
    on left: 74 75 76 77, on right: 83
stats (88)
    on left: 78 79 80, on right: 73 79
stat (89)
    on left: 81 82 83 84 85 86 87 88, on right: 79 80
defineStats (90)
    on left: 89 90 91, on right: 73 90
defineStat (91)
    on left: 92 93 94, on right: 90 91
defineSwitch (92)
    on left: 96, on right: 88
@8 (93)
    on left: 95, on right: 96
switchSpace (94)
    on left: 97 98, on right: 96 98
switchStats (95)
    on left: 99 100, on right: 97 99
switchStat (96)
    on left: 101 102 104 106, on right: 99 100
@9 (97)
    on left: 103, on right: 104
@10 (98)
    on left: 105, on right: 106
defineType (99)
    on left: 107 108, on right: 29 34 35 57 65 66 109 110
typeListP (100)
    on left: 109 110, on right: 109 112
typeList (101)
    on left: 111 112, on right: 35
defineVariale (102)
    on left: 113, on right: 94
defineWhile (103)
    on left: 115, on right: 86
@11 (104)
    on left: 114, on right: 115


state 0

    0 $accept: . program $end

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    DINIT      shift, and go to state 4

    $end       reduce using rule 8 (program)
    $end       [reduce using rule 89 (defineStats)]
    NAME       [reduce using rule 89 (defineStats)]
    ENDL       [reduce using rule 89 (defineStats)]
    SEMICOLON  [reduce using rule 89 (defineStats)]
    $default   reduce using rule 89 (defineStats)

    endls          go to state 5
    endc           go to state 6
    name           go to state 7
    program        go to state 8
    defineFunc     go to state 9
    funcType       go to state 10
    init           go to state 11
    defineParam    go to state 12
    paramListP     go to state 13
    space          go to state 14
    defineStats    go to state 15
    defineStat     go to state 16
    defineType     go to state 17
    defineVariale  go to state 18


state 1

    7 name: NAME .

    $default  reduce using rule 7 (name)


state 2

    2 endls: ENDL .

    $default  reduce using rule 2 (endls)


state 3

    3 endc: SEMICOLON .

    $default  reduce using rule 3 (endc)


state 4

   51 init: DINIT . endls initContext DEND endls

    ENDL  shift, and go to state 2

    endls  go to state 19


state 5

    1 endls: endls . ENDL
    4 endc: endls .

    ENDL  shift, and go to state 20

    ENDL      [reduce using rule 4 (endc)]
    $default  reduce using rule 4 (endc)


state 6

   92 defineStat: endc .

    $default  reduce using rule 92 (defineStat)


state 7

  107 defineType: name .

    $default  reduce using rule 107 (defineType)


state 8

    0 $accept: program . $end

    $end  shift, and go to state 21


state 9

   93 defineStat: defineFunc . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 5
    endc   go to state 22


state 10

  108 defineType: funcType .

    $default  reduce using rule 108 (defineType)


state 11

    9 program: init .

    $default  reduce using rule 9 (program)


state 12

   68 paramListP: defineParam .

    $default  reduce using rule 68 (paramListP)


state 13

   67 paramListP: paramListP . list defineParam
  113 defineVariale: paramListP .

    COMMA  shift, and go to state 23

    $default  reduce using rule 113 (defineVariale)

    list  go to state 24


state 14

   10 program: space .

    $default  reduce using rule 10 (program)


state 15

   73 space: defineStats . stats
   90 defineStats: defineStats . defineStat

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    RETURN     shift, and go to state 25
    IF         shift, and go to state 26
    FOR        shift, and go to state 27
    WHILE      shift, and go to state 28
    SWITCH     shift, and go to state 29
    BREAK      shift, and go to state 30
    CONTINUE   shift, and go to state 31

    NAME       [reduce using rule 78 (stats)]
    ENDL       [reduce using rule 78 (stats)]
    SEMICOLON  [reduce using rule 78 (stats)]
    RETURN     [reduce using rule 78 (stats)]
    IF         [reduce using rule 78 (stats)]
    FOR        [reduce using rule 78 (stats)]
    WHILE      [reduce using rule 78 (stats)]
    SWITCH     [reduce using rule 78 (stats)]
    BREAK      [reduce using rule 78 (stats)]
    CONTINUE   [reduce using rule 78 (stats)]
    $default   reduce using rule 78 (stats)

    endls          go to state 5
    endc           go to state 32
    name           go to state 33
    defineFor      go to state 34
    defineFunc     go to state 9
    funcType       go to state 10
    defineIden     go to state 35
    idenFunc       go to state 36
    defineIf       go to state 37
    ifPart         go to state 38
    assignment     go to state 39
    iteration      go to state 40
    defineParam    go to state 12
    paramListP     go to state 13
    controlSpace   go to state 41
    stats          go to state 42
    stat           go to state 43
    defineStat     go to state 44
    defineSwitch   go to state 45
    defineType     go to state 17
    defineVariale  go to state 18
    defineWhile    go to state 46


state 16

   91 defineStats: defineStat .

    $default  reduce using rule 91 (defineStats)


state 17

   29 defineFunc: defineType . name funcHeaderV @2 subSpace
   35 funcType: defineType . COLON RPAREN typeList LPAREN
   65 defineParam: defineType . name
   66            | defineType . name ASSIGN expr

    NAME   shift, and go to state 1
    COLON  shift, and go to state 47

    name  go to state 48


state 18

   94 defineStat: defineVariale . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 5
    endc   go to state 49


state 19

    1 endls: endls . ENDL
   51 init: DINIT endls . initContext DEND endls

    ENDL      shift, and go to state 20
    OPERATOR  shift, and go to state 50

    initContext   go to state 51
    initOperator  go to state 52


state 20

    1 endls: endls ENDL .

    $default  reduce using rule 1 (endls)


state 21

    0 $accept: program $end .

    $default  accept


state 22

   93 defineStat: defineFunc endc .

    $default  reduce using rule 93 (defineStat)


state 23

    5 list: COMMA .

    $default  reduce using rule 5 (list)


state 24

    6 list: list . endls
   67 paramListP: paramListP list . defineParam

    NAME  shift, and go to state 1
    ENDL  shift, and go to state 2

    endls        go to state 53
    name         go to state 7
    funcType     go to state 10
    defineParam  go to state 54
    defineType   go to state 55


state 25

   74 controlSpace: RETURN . expr
   75             | RETURN .

    NAME           shift, and go to state 1
    INT            shift, and go to state 56
    NUMBER         shift, and go to state 57
    STRING         shift, and go to state 58
    VALUE_BOOLEAN  shift, and go to state 59
    VALUE_VOID     shift, and go to state 60
    RPAREN         shift, and go to state 61

    $default  reduce using rule 75 (controlSpace)

    name         go to state 62
    expr         go to state 63
    funcExpr     go to state 64
    funcHeaderE  go to state 65
    defineIden   go to state 66
    idenFunc     go to state 67


state 26

   44 ifPart: IF . RPAREN expr LPAREN @5 subSpace

    RPAREN  shift, and go to state 68


state 27

   27 defineFor: FOR . RPAREN paramList @1 SEMICOLON expr SEMICOLON iteration LPAREN subSpace

    RPAREN  shift, and go to state 69


state 28

  115 defineWhile: WHILE . RPAREN expr LPAREN @11 subSpace

    RPAREN  shift, and go to state 70


state 29

   96 defineSwitch: SWITCH . RPAREN expr LPAREN @8 switchSpace

    RPAREN  shift, and go to state 71


state 30

   76 controlSpace: BREAK .

    $default  reduce using rule 76 (controlSpace)


state 31

   77 controlSpace: CONTINUE .

    $default  reduce using rule 77 (controlSpace)


state 32

   81 stat: endc .
   92 defineStat: endc .

    $end       reduce using rule 81 (stat)
    $end       [reduce using rule 92 (defineStat)]
    NAME       reduce using rule 81 (stat)
    NAME       [reduce using rule 92 (defineStat)]
    ENDL       reduce using rule 81 (stat)
    ENDL       [reduce using rule 92 (defineStat)]
    SEMICOLON  reduce using rule 81 (stat)
    SEMICOLON  [reduce using rule 92 (defineStat)]
    LBRACE     reduce using rule 81 (stat)
    LBRACE     [reduce using rule 92 (defineStat)]
    RETURN     reduce using rule 81 (stat)
    RETURN     [reduce using rule 92 (defineStat)]
    IF         reduce using rule 81 (stat)
    IF         [reduce using rule 92 (defineStat)]
    FOR        reduce using rule 81 (stat)
    FOR        [reduce using rule 92 (defineStat)]
    WHILE      reduce using rule 81 (stat)
    WHILE      [reduce using rule 92 (defineStat)]
    SWITCH     reduce using rule 81 (stat)
    SWITCH     [reduce using rule 92 (defineStat)]
    BREAK      reduce using rule 81 (stat)
    BREAK      [reduce using rule 92 (defineStat)]
    CONTINUE   reduce using rule 81 (stat)
    CONTINUE   [reduce using rule 92 (defineStat)]
    $default   reduce using rule 81 (stat)


state 33

   36 defineIden: name .
  107 defineType: name .

    NAME      reduce using rule 107 (defineType)
    COLON     reduce using rule 107 (defineType)
    $default  reduce using rule 36 (defineIden)


state 34

   87 stat: defineFor . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 5
    endc   go to state 72


state 35

   38 idenFunc: defineIden . RPAREN exprList LPAREN
   58 assignment: defineIden . ASSIGN expr

    ASSIGN  shift, and go to state 73
    RPAREN  shift, and go to state 74


state 36

   37 defineIden: idenFunc .
   84 stat: idenFunc . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    $default  reduce using rule 37 (defineIden)

    endls  go to state 5
    endc   go to state 75


state 37

   85 stat: defineIf . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 5
    endc   go to state 76


state 38

   39 defineIf: ifPart .
   40         | ifPart . elseIfParts
   41         | ifPart . elsePart
   42         | ifPart . elseIfParts elsePart

    ELSE  shift, and go to state 77

    $default  reduce using rule 39 (defineIf)

    elseIfParts  go to state 78
    elseIfPart   go to state 79
    elsePart     go to state 80


state 39

   59 iteration: assignment .

    $default  reduce using rule 59 (iteration)


state 40

   82 stat: iteration . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 5
    endc   go to state 81


state 41

   83 stat: controlSpace . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 5
    endc   go to state 82


state 42

   73 space: defineStats stats .
   79 stats: stats . stat

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3
    RETURN     shift, and go to state 25
    IF         shift, and go to state 26
    FOR        shift, and go to state 27
    WHILE      shift, and go to state 28
    SWITCH     shift, and go to state 29
    BREAK      shift, and go to state 30
    CONTINUE   shift, and go to state 31

    $default  reduce using rule 73 (space)

    endls         go to state 5
    endc          go to state 83
    name          go to state 62
    defineFor     go to state 34
    defineIden    go to state 35
    idenFunc      go to state 36
    defineIf      go to state 37
    ifPart        go to state 38
    assignment    go to state 39
    iteration     go to state 40
    controlSpace  go to state 41
    stat          go to state 84
    defineSwitch  go to state 45
    defineWhile   go to state 46


state 43

   80 stats: stat .

    $default  reduce using rule 80 (stats)


state 44

   90 defineStats: defineStats defineStat .

    $default  reduce using rule 90 (defineStats)


state 45

   88 stat: defineSwitch . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 5
    endc   go to state 85


state 46

   86 stat: defineWhile . endc

    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    endls  go to state 5
    endc   go to state 86


state 47

   35 funcType: defineType COLON . RPAREN typeList LPAREN

    RPAREN  shift, and go to state 87


state 48

   29 defineFunc: defineType name . funcHeaderV @2 subSpace
   65 defineParam: defineType name .
   66            | defineType name . ASSIGN expr

    ASSIGN  shift, and go to state 88
    RPAREN  shift, and go to state 89

    $default  reduce using rule 65 (defineParam)

    funcHeaderV  go to state 90


state 49

   94 defineStat: defineVariale endc .

    $default  reduce using rule 94 (defineStat)


state 50

   53 initOperator: OPERATOR . RBRACE initOperatorContexts LBRACE endls

    RBRACE  shift, and go to state 91


state 51

   51 init: DINIT endls initContext . DEND endls

    DEND  shift, and go to state 92


state 52

   52 initContext: initOperator .

    $default  reduce using rule 52 (initContext)


state 53

    1 endls: endls . ENDL
    6 list: list endls .

    ENDL  shift, and go to state 20

    ENDL      [reduce using rule 6 (list)]
    $default  reduce using rule 6 (list)


state 54

   67 paramListP: paramListP list defineParam .

    $default  reduce using rule 67 (paramListP)


state 55

   35 funcType: defineType . COLON RPAREN typeList LPAREN
   65 defineParam: defineType . name
   66            | defineType . name ASSIGN expr

    NAME   shift, and go to state 1
    COLON  shift, and go to state 47

    name  go to state 93


state 56

   19 expr: INT .

    $default  reduce using rule 19 (expr)


state 57

   20 expr: NUMBER .

    $default  reduce using rule 20 (expr)


state 58

   16 expr: STRING .

    $default  reduce using rule 16 (expr)


state 59

   18 expr: VALUE_BOOLEAN .

    $default  reduce using rule 18 (expr)


state 60

   17 expr: VALUE_VOID .

    $default  reduce using rule 17 (expr)


state 61

   34 funcHeaderE: RPAREN . @4 paramList LPAREN COLON defineType

    $default  reduce using rule 33 (@4)

    @4  go to state 94


state 62

   36 defineIden: name .

    $default  reduce using rule 36 (defineIden)


state 63

   11 expr: expr . PLUS expr
   12     | expr . MINUS expr
   13     | expr . MULT expr
   14     | expr . DIVIDE expr
   15     | expr . MODULUS expr
   74 controlSpace: RETURN expr .

    MINUS    shift, and go to state 95
    PLUS     shift, and go to state 96
    MODULUS  shift, and go to state 97
    DIVIDE   shift, and go to state 98
    MULT     shift, and go to state 99

    $default  reduce using rule 74 (controlSpace)


state 64

   22 expr: funcExpr .

    $default  reduce using rule 22 (expr)


state 65

   31 funcExpr: funcHeaderE . @3 subSpace

    $default  reduce using rule 30 (@3)

    @3  go to state 100


state 66

   21 expr: defineIden .
   38 idenFunc: defineIden . RPAREN exprList LPAREN

    RPAREN  shift, and go to state 74

    $default  reduce using rule 21 (expr)


state 67

   37 defineIden: idenFunc .

    $default  reduce using rule 37 (defineIden)


state 68

   44 ifPart: IF RPAREN . expr LPAREN @5 subSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 56
    NUMBER         shift, and go to state 57
    STRING         shift, and go to state 58
    VALUE_BOOLEAN  shift, and go to state 59
    VALUE_VOID     shift, and go to state 60
    RPAREN         shift, and go to state 61

    name         go to state 62
    expr         go to state 101
    funcExpr     go to state 64
    funcHeaderE  go to state 65
    defineIden   go to state 66
    idenFunc     go to state 67


state 69

   27 defineFor: FOR RPAREN . paramList @1 SEMICOLON expr SEMICOLON iteration LPAREN subSpace

    NAME  shift, and go to state 1

    $default  reduce using rule 69 (paramList)

    name         go to state 7
    funcType     go to state 10
    defineParam  go to state 12
    paramListP   go to state 102
    paramList    go to state 103
    defineType   go to state 55


state 70

  115 defineWhile: WHILE RPAREN . expr LPAREN @11 subSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 56
    NUMBER         shift, and go to state 57
    STRING         shift, and go to state 58
    VALUE_BOOLEAN  shift, and go to state 59
    VALUE_VOID     shift, and go to state 60
    RPAREN         shift, and go to state 61

    name         go to state 62
    expr         go to state 104
    funcExpr     go to state 64
    funcHeaderE  go to state 65
    defineIden   go to state 66
    idenFunc     go to state 67


state 71

   96 defineSwitch: SWITCH RPAREN . expr LPAREN @8 switchSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 56
    NUMBER         shift, and go to state 57
    STRING         shift, and go to state 58
    VALUE_BOOLEAN  shift, and go to state 59
    VALUE_VOID     shift, and go to state 60
    RPAREN         shift, and go to state 61

    name         go to state 62
    expr         go to state 105
    funcExpr     go to state 64
    funcHeaderE  go to state 65
    defineIden   go to state 66
    idenFunc     go to state 67


state 72

   87 stat: defineFor endc .

    $default  reduce using rule 87 (stat)


state 73

   58 assignment: defineIden ASSIGN . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 56
    NUMBER         shift, and go to state 57
    STRING         shift, and go to state 58
    VALUE_BOOLEAN  shift, and go to state 59
    VALUE_VOID     shift, and go to state 60
    RPAREN         shift, and go to state 61

    name         go to state 62
    expr         go to state 106
    funcExpr     go to state 64
    funcHeaderE  go to state 65
    defineIden   go to state 66
    idenFunc     go to state 67


state 74

   38 idenFunc: defineIden RPAREN . exprList LPAREN

    NAME           shift, and go to state 1
    INT            shift, and go to state 56
    NUMBER         shift, and go to state 57
    STRING         shift, and go to state 58
    VALUE_BOOLEAN  shift, and go to state 59
    VALUE_VOID     shift, and go to state 60
    RPAREN         shift, and go to state 61

    $default  reduce using rule 23 (exprList)

    name         go to state 62
    expr         go to state 107
    exprList     go to state 108
    funcExpr     go to state 64
    funcHeaderE  go to state 65
    defineIden   go to state 66
    idenFunc     go to state 67


state 75

   84 stat: idenFunc endc .

    $default  reduce using rule 84 (stat)


state 76

   85 stat: defineIf endc .

    $default  reduce using rule 85 (stat)


state 77

   48 elseIfPart: ELSE . IF RPAREN expr LPAREN @6 subSpace
   50 elsePart: ELSE . @7 subSpace

    IF  shift, and go to state 109

    $default  reduce using rule 49 (@7)

    @7  go to state 110


state 78

   40 defineIf: ifPart elseIfParts .
   42         | ifPart elseIfParts . elsePart
   45 elseIfParts: elseIfParts . elseIfPart

    ELSE  shift, and go to state 77

    $default  reduce using rule 40 (defineIf)

    elseIfPart  go to state 111
    elsePart    go to state 112


state 79

   46 elseIfParts: elseIfPart .

    $default  reduce using rule 46 (elseIfParts)


state 80

   41 defineIf: ifPart elsePart .

    $default  reduce using rule 41 (defineIf)


state 81

   82 stat: iteration endc .

    $default  reduce using rule 82 (stat)


state 82

   83 stat: controlSpace endc .

    $default  reduce using rule 83 (stat)


state 83

   81 stat: endc .

    $default  reduce using rule 81 (stat)


state 84

   79 stats: stats stat .

    $default  reduce using rule 79 (stats)


state 85

   88 stat: defineSwitch endc .

    $default  reduce using rule 88 (stat)


state 86

   86 stat: defineWhile endc .

    $default  reduce using rule 86 (stat)


state 87

   35 funcType: defineType COLON RPAREN . typeList LPAREN

    NAME  shift, and go to state 1

    $default  reduce using rule 111 (typeList)

    name        go to state 7
    funcType    go to state 10
    defineType  go to state 113
    typeListP   go to state 114
    typeList    go to state 115


state 88

   66 defineParam: defineType name ASSIGN . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 56
    NUMBER         shift, and go to state 57
    STRING         shift, and go to state 58
    VALUE_BOOLEAN  shift, and go to state 59
    VALUE_VOID     shift, and go to state 60
    RPAREN         shift, and go to state 61

    name         go to state 62
    expr         go to state 116
    funcExpr     go to state 64
    funcHeaderE  go to state 65
    defineIden   go to state 66
    idenFunc     go to state 67


state 89

   32 funcHeaderV: RPAREN . paramList LPAREN

    NAME  shift, and go to state 1

    $default  reduce using rule 69 (paramList)

    name         go to state 7
    funcType     go to state 10
    defineParam  go to state 12
    paramListP   go to state 102
    paramList    go to state 117
    defineType   go to state 55


state 90

   29 defineFunc: defineType name funcHeaderV . @2 subSpace

    $default  reduce using rule 28 (@2)

    @2  go to state 118


state 91

   53 initOperator: OPERATOR RBRACE . initOperatorContexts LBRACE endls

    NAME  shift, and go to state 1
    ENDL  shift, and go to state 2

    endls                 go to state 119
    name                  go to state 7
    funcType              go to state 10
    initOperatorContexts  go to state 120
    initOperatorContext   go to state 121
    defineType            go to state 122


state 92

   51 init: DINIT endls initContext DEND . endls

    ENDL  shift, and go to state 2

    endls  go to state 123


state 93

   65 defineParam: defineType name .
   66            | defineType name . ASSIGN expr

    ASSIGN  shift, and go to state 88

    $default  reduce using rule 65 (defineParam)


state 94

   34 funcHeaderE: RPAREN @4 . paramList LPAREN COLON defineType

    NAME  shift, and go to state 1

    $default  reduce using rule 69 (paramList)

    name         go to state 7
    funcType     go to state 10
    defineParam  go to state 12
    paramListP   go to state 102
    paramList    go to state 124
    defineType   go to state 55


state 95

   12 expr: expr MINUS . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 56
    NUMBER         shift, and go to state 57
    STRING         shift, and go to state 58
    VALUE_BOOLEAN  shift, and go to state 59
    VALUE_VOID     shift, and go to state 60
    RPAREN         shift, and go to state 61

    name         go to state 62
    expr         go to state 125
    funcExpr     go to state 64
    funcHeaderE  go to state 65
    defineIden   go to state 66
    idenFunc     go to state 67


state 96

   11 expr: expr PLUS . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 56
    NUMBER         shift, and go to state 57
    STRING         shift, and go to state 58
    VALUE_BOOLEAN  shift, and go to state 59
    VALUE_VOID     shift, and go to state 60
    RPAREN         shift, and go to state 61

    name         go to state 62
    expr         go to state 126
    funcExpr     go to state 64
    funcHeaderE  go to state 65
    defineIden   go to state 66
    idenFunc     go to state 67


state 97

   15 expr: expr MODULUS . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 56
    NUMBER         shift, and go to state 57
    STRING         shift, and go to state 58
    VALUE_BOOLEAN  shift, and go to state 59
    VALUE_VOID     shift, and go to state 60
    RPAREN         shift, and go to state 61

    name         go to state 62
    expr         go to state 127
    funcExpr     go to state 64
    funcHeaderE  go to state 65
    defineIden   go to state 66
    idenFunc     go to state 67


state 98

   14 expr: expr DIVIDE . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 56
    NUMBER         shift, and go to state 57
    STRING         shift, and go to state 58
    VALUE_BOOLEAN  shift, and go to state 59
    VALUE_VOID     shift, and go to state 60
    RPAREN         shift, and go to state 61

    name         go to state 62
    expr         go to state 128
    funcExpr     go to state 64
    funcHeaderE  go to state 65
    defineIden   go to state 66
    idenFunc     go to state 67


state 99

   13 expr: expr MULT . expr

    NAME           shift, and go to state 1
    INT            shift, and go to state 56
    NUMBER         shift, and go to state 57
    STRING         shift, and go to state 58
    VALUE_BOOLEAN  shift, and go to state 59
    VALUE_VOID     shift, and go to state 60
    RPAREN         shift, and go to state 61

    name         go to state 62
    expr         go to state 129
    funcExpr     go to state 64
    funcHeaderE  go to state 65
    defineIden   go to state 66
    idenFunc     go to state 67


state 100

   31 funcExpr: funcHeaderE @3 . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 130

    endls     go to state 131
    subSpace  go to state 132


state 101

   11 expr: expr . PLUS expr
   12     | expr . MINUS expr
   13     | expr . MULT expr
   14     | expr . DIVIDE expr
   15     | expr . MODULUS expr
   44 ifPart: IF RPAREN expr . LPAREN @5 subSpace

    MINUS    shift, and go to state 95
    PLUS     shift, and go to state 96
    MODULUS  shift, and go to state 97
    DIVIDE   shift, and go to state 98
    MULT     shift, and go to state 99
    LPAREN   shift, and go to state 133


state 102

   67 paramListP: paramListP . list defineParam
   70 paramList: paramListP .

    COMMA  shift, and go to state 23

    $default  reduce using rule 70 (paramList)

    list  go to state 24


state 103

   27 defineFor: FOR RPAREN paramList . @1 SEMICOLON expr SEMICOLON iteration LPAREN subSpace

    $default  reduce using rule 26 (@1)

    @1  go to state 134


state 104

   11 expr: expr . PLUS expr
   12     | expr . MINUS expr
   13     | expr . MULT expr
   14     | expr . DIVIDE expr
   15     | expr . MODULUS expr
  115 defineWhile: WHILE RPAREN expr . LPAREN @11 subSpace

    MINUS    shift, and go to state 95
    PLUS     shift, and go to state 96
    MODULUS  shift, and go to state 97
    DIVIDE   shift, and go to state 98
    MULT     shift, and go to state 99
    LPAREN   shift, and go to state 135


state 105

   11 expr: expr . PLUS expr
   12     | expr . MINUS expr
   13     | expr . MULT expr
   14     | expr . DIVIDE expr
   15     | expr . MODULUS expr
   96 defineSwitch: SWITCH RPAREN expr . LPAREN @8 switchSpace

    MINUS    shift, and go to state 95
    PLUS     shift, and go to state 96
    MODULUS  shift, and go to state 97
    DIVIDE   shift, and go to state 98
    MULT     shift, and go to state 99
    LPAREN   shift, and go to state 136


state 106

   11 expr: expr . PLUS expr
   12     | expr . MINUS expr
   13     | expr . MULT expr
   14     | expr . DIVIDE expr
   15     | expr . MODULUS expr
   58 assignment: defineIden ASSIGN expr .

    MINUS    shift, and go to state 95
    PLUS     shift, and go to state 96
    MODULUS  shift, and go to state 97
    DIVIDE   shift, and go to state 98
    MULT     shift, and go to state 99

    $default  reduce using rule 58 (assignment)


state 107

   11 expr: expr . PLUS expr
   12     | expr . MINUS expr
   13     | expr . MULT expr
   14     | expr . DIVIDE expr
   15     | expr . MODULUS expr
   25 exprList: expr .

    MINUS    shift, and go to state 95
    PLUS     shift, and go to state 96
    MODULUS  shift, and go to state 97
    DIVIDE   shift, and go to state 98
    MULT     shift, and go to state 99

    $default  reduce using rule 25 (exprList)


state 108

   24 exprList: exprList . list expr
   38 idenFunc: defineIden RPAREN exprList . LPAREN

    LPAREN  shift, and go to state 137
    COMMA   shift, and go to state 23

    list  go to state 138


state 109

   48 elseIfPart: ELSE IF . RPAREN expr LPAREN @6 subSpace

    RPAREN  shift, and go to state 139


state 110

   50 elsePart: ELSE @7 . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 130

    endls     go to state 131
    subSpace  go to state 140


state 111

   45 elseIfParts: elseIfParts elseIfPart .

    $default  reduce using rule 45 (elseIfParts)


state 112

   42 defineIf: ifPart elseIfParts elsePart .

    $default  reduce using rule 42 (defineIf)


state 113

   35 funcType: defineType . COLON RPAREN typeList LPAREN
  110 typeListP: defineType .

    COLON  shift, and go to state 47

    $default  reduce using rule 110 (typeListP)


state 114

  109 typeListP: typeListP . list defineType
  112 typeList: typeListP .

    COMMA  shift, and go to state 23

    $default  reduce using rule 112 (typeList)

    list  go to state 141


state 115

   35 funcType: defineType COLON RPAREN typeList . LPAREN

    LPAREN  shift, and go to state 142


state 116

   11 expr: expr . PLUS expr
   12     | expr . MINUS expr
   13     | expr . MULT expr
   14     | expr . DIVIDE expr
   15     | expr . MODULUS expr
   66 defineParam: defineType name ASSIGN expr .

    MINUS    shift, and go to state 95
    PLUS     shift, and go to state 96
    MODULUS  shift, and go to state 97
    DIVIDE   shift, and go to state 98
    MULT     shift, and go to state 99

    $default  reduce using rule 66 (defineParam)


state 117

   32 funcHeaderV: RPAREN paramList . LPAREN

    LPAREN  shift, and go to state 143


state 118

   29 defineFunc: defineType name funcHeaderV @2 . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 130

    endls     go to state 131
    subSpace  go to state 144


state 119

    1 endls: endls . ENDL
   56 initOperatorContext: endls .

    ENDL  shift, and go to state 20

    ENDL      [reduce using rule 56 (initOperatorContext)]
    $default  reduce using rule 56 (initOperatorContext)


state 120

   53 initOperator: OPERATOR RBRACE initOperatorContexts . LBRACE endls
   54 initOperatorContexts: initOperatorContexts . initOperatorContext

    NAME    shift, and go to state 1
    ENDL    shift, and go to state 2
    LBRACE  shift, and go to state 145

    endls                go to state 119
    name                 go to state 7
    funcType             go to state 10
    initOperatorContext  go to state 146
    defineType           go to state 122


state 121

   55 initOperatorContexts: initOperatorContext .

    $default  reduce using rule 55 (initOperatorContexts)


state 122

   35 funcType: defineType . COLON RPAREN typeList LPAREN
   57 initOperatorContext: defineType . operator defineType ASSIGN name endls

    MINUS    shift, and go to state 147
    PLUS     shift, and go to state 148
    MODULUS  shift, and go to state 149
    DIVIDE   shift, and go to state 150
    MULT     shift, and go to state 151
    COLON    shift, and go to state 47

    operator  go to state 152


state 123

    1 endls: endls . ENDL
   51 init: DINIT endls initContext DEND endls .

    ENDL  shift, and go to state 20

    $default  reduce using rule 51 (init)


state 124

   34 funcHeaderE: RPAREN @4 paramList . LPAREN COLON defineType

    LPAREN  shift, and go to state 153


state 125

   11 expr: expr . PLUS expr
   12     | expr . MINUS expr
   12     | expr MINUS expr .
   13     | expr . MULT expr
   14     | expr . DIVIDE expr
   15     | expr . MODULUS expr

    MODULUS  shift, and go to state 97
    DIVIDE   shift, and go to state 98
    MULT     shift, and go to state 99

    $default  reduce using rule 12 (expr)


state 126

   11 expr: expr . PLUS expr
   11     | expr PLUS expr .
   12     | expr . MINUS expr
   13     | expr . MULT expr
   14     | expr . DIVIDE expr
   15     | expr . MODULUS expr

    MODULUS  shift, and go to state 97
    DIVIDE   shift, and go to state 98
    MULT     shift, and go to state 99

    $default  reduce using rule 11 (expr)


state 127

   11 expr: expr . PLUS expr
   12     | expr . MINUS expr
   13     | expr . MULT expr
   14     | expr . DIVIDE expr
   15     | expr . MODULUS expr
   15     | expr MODULUS expr .

    $default  reduce using rule 15 (expr)


state 128

   11 expr: expr . PLUS expr
   12     | expr . MINUS expr
   13     | expr . MULT expr
   14     | expr . DIVIDE expr
   14     | expr DIVIDE expr .
   15     | expr . MODULUS expr

    $default  reduce using rule 14 (expr)


state 129

   11 expr: expr . PLUS expr
   12     | expr . MINUS expr
   13     | expr . MULT expr
   13     | expr MULT expr .
   14     | expr . DIVIDE expr
   15     | expr . MODULUS expr

    $default  reduce using rule 13 (expr)


state 130

   71 subSpace: RBRACE . space LBRACE

    NAME       shift, and go to state 1
    ENDL       shift, and go to state 2
    SEMICOLON  shift, and go to state 3

    NAME       [reduce using rule 89 (defineStats)]
    ENDL       [reduce using rule 89 (defineStats)]
    SEMICOLON  [reduce using rule 89 (defineStats)]
    $default   reduce using rule 89 (defineStats)

    endls          go to state 5
    endc           go to state 6
    name           go to state 7
    defineFunc     go to state 9
    funcType       go to state 10
    defineParam    go to state 12
    paramListP     go to state 13
    space          go to state 154
    defineStats    go to state 15
    defineStat     go to state 16
    defineType     go to state 17
    defineVariale  go to state 18


state 131

    1 endls: endls . ENDL
   72 subSpace: endls . subSpace

    ENDL    shift, and go to state 155
    RBRACE  shift, and go to state 130

    endls     go to state 131
    subSpace  go to state 156


state 132

   31 funcExpr: funcHeaderE @3 subSpace .

    $default  reduce using rule 31 (funcExpr)


state 133

   44 ifPart: IF RPAREN expr LPAREN . @5 subSpace

    $default  reduce using rule 43 (@5)

    @5  go to state 157


state 134

   27 defineFor: FOR RPAREN paramList @1 . SEMICOLON expr SEMICOLON iteration LPAREN subSpace

    SEMICOLON  shift, and go to state 158


state 135

  115 defineWhile: WHILE RPAREN expr LPAREN . @11 subSpace

    $default  reduce using rule 114 (@11)

    @11  go to state 159


state 136

   96 defineSwitch: SWITCH RPAREN expr LPAREN . @8 switchSpace

    $default  reduce using rule 95 (@8)

    @8  go to state 160


state 137

   38 idenFunc: defineIden RPAREN exprList LPAREN .

    $default  reduce using rule 38 (idenFunc)


state 138

    6 list: list . endls
   24 exprList: exprList list . expr

    NAME           shift, and go to state 1
    ENDL           shift, and go to state 2
    INT            shift, and go to state 56
    NUMBER         shift, and go to state 57
    STRING         shift, and go to state 58
    VALUE_BOOLEAN  shift, and go to state 59
    VALUE_VOID     shift, and go to state 60
    RPAREN         shift, and go to state 61

    endls        go to state 53
    name         go to state 62
    expr         go to state 161
    funcExpr     go to state 64
    funcHeaderE  go to state 65
    defineIden   go to state 66
    idenFunc     go to state 67


state 139

   48 elseIfPart: ELSE IF RPAREN . expr LPAREN @6 subSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 56
    NUMBER         shift, and go to state 57
    STRING         shift, and go to state 58
    VALUE_BOOLEAN  shift, and go to state 59
    VALUE_VOID     shift, and go to state 60
    RPAREN         shift, and go to state 61

    name         go to state 62
    expr         go to state 162
    funcExpr     go to state 64
    funcHeaderE  go to state 65
    defineIden   go to state 66
    idenFunc     go to state 67


state 140

   50 elsePart: ELSE @7 subSpace .

    $default  reduce using rule 50 (elsePart)


state 141

    6 list: list . endls
  109 typeListP: typeListP list . defineType

    NAME  shift, and go to state 1
    ENDL  shift, and go to state 2

    endls       go to state 53
    name        go to state 7
    funcType    go to state 10
    defineType  go to state 163


state 142

   35 funcType: defineType COLON RPAREN typeList LPAREN .

    $default  reduce using rule 35 (funcType)


state 143

   32 funcHeaderV: RPAREN paramList LPAREN .

    $default  reduce using rule 32 (funcHeaderV)


state 144

   29 defineFunc: defineType name funcHeaderV @2 subSpace .

    $default  reduce using rule 29 (defineFunc)


state 145

   53 initOperator: OPERATOR RBRACE initOperatorContexts LBRACE . endls

    ENDL  shift, and go to state 2

    endls  go to state 164


state 146

   54 initOperatorContexts: initOperatorContexts initOperatorContext .

    $default  reduce using rule 54 (initOperatorContexts)


state 147

   61 operator: MINUS .

    $default  reduce using rule 61 (operator)


state 148

   60 operator: PLUS .

    $default  reduce using rule 60 (operator)


state 149

   64 operator: MODULUS .

    $default  reduce using rule 64 (operator)


state 150

   63 operator: DIVIDE .

    $default  reduce using rule 63 (operator)


state 151

   62 operator: MULT .

    $default  reduce using rule 62 (operator)


state 152

   57 initOperatorContext: defineType operator . defineType ASSIGN name endls

    NAME  shift, and go to state 1

    name        go to state 7
    funcType    go to state 10
    defineType  go to state 165


state 153

   34 funcHeaderE: RPAREN @4 paramList LPAREN . COLON defineType

    COLON  shift, and go to state 166


state 154

   71 subSpace: RBRACE space . LBRACE

    LBRACE  shift, and go to state 167


state 155

    1 endls: endls ENDL .
    2      | ENDL .

    ENDL      reduce using rule 1 (endls)
    ENDL      [reduce using rule 2 (endls)]
    RBRACE    reduce using rule 1 (endls)
    RBRACE    [reduce using rule 2 (endls)]
    $default  reduce using rule 1 (endls)


state 156

   72 subSpace: endls subSpace .

    $default  reduce using rule 72 (subSpace)


state 157

   44 ifPart: IF RPAREN expr LPAREN @5 . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 130

    endls     go to state 131
    subSpace  go to state 168


state 158

   27 defineFor: FOR RPAREN paramList @1 SEMICOLON . expr SEMICOLON iteration LPAREN subSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 56
    NUMBER         shift, and go to state 57
    STRING         shift, and go to state 58
    VALUE_BOOLEAN  shift, and go to state 59
    VALUE_VOID     shift, and go to state 60
    RPAREN         shift, and go to state 61

    name         go to state 62
    expr         go to state 169
    funcExpr     go to state 64
    funcHeaderE  go to state 65
    defineIden   go to state 66
    idenFunc     go to state 67


state 159

  115 defineWhile: WHILE RPAREN expr LPAREN @11 . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 130

    endls     go to state 131
    subSpace  go to state 170


state 160

   96 defineSwitch: SWITCH RPAREN expr LPAREN @8 . switchSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 171

    endls        go to state 172
    switchSpace  go to state 173


state 161

   11 expr: expr . PLUS expr
   12     | expr . MINUS expr
   13     | expr . MULT expr
   14     | expr . DIVIDE expr
   15     | expr . MODULUS expr
   24 exprList: exprList list expr .

    MINUS    shift, and go to state 95
    PLUS     shift, and go to state 96
    MODULUS  shift, and go to state 97
    DIVIDE   shift, and go to state 98
    MULT     shift, and go to state 99

    $default  reduce using rule 24 (exprList)


state 162

   11 expr: expr . PLUS expr
   12     | expr . MINUS expr
   13     | expr . MULT expr
   14     | expr . DIVIDE expr
   15     | expr . MODULUS expr
   48 elseIfPart: ELSE IF RPAREN expr . LPAREN @6 subSpace

    MINUS    shift, and go to state 95
    PLUS     shift, and go to state 96
    MODULUS  shift, and go to state 97
    DIVIDE   shift, and go to state 98
    MULT     shift, and go to state 99
    LPAREN   shift, and go to state 174


state 163

   35 funcType: defineType . COLON RPAREN typeList LPAREN
  109 typeListP: typeListP list defineType .

    COLON  shift, and go to state 47

    $default  reduce using rule 109 (typeListP)


state 164

    1 endls: endls . ENDL
   53 initOperator: OPERATOR RBRACE initOperatorContexts LBRACE endls .

    ENDL  shift, and go to state 20

    $default  reduce using rule 53 (initOperator)


state 165

   35 funcType: defineType . COLON RPAREN typeList LPAREN
   57 initOperatorContext: defineType operator defineType . ASSIGN name endls

    COLON   shift, and go to state 47
    ASSIGN  shift, and go to state 175


state 166

   34 funcHeaderE: RPAREN @4 paramList LPAREN COLON . defineType

    NAME  shift, and go to state 1

    name        go to state 7
    funcType    go to state 10
    defineType  go to state 176


state 167

   71 subSpace: RBRACE space LBRACE .

    $default  reduce using rule 71 (subSpace)


state 168

   44 ifPart: IF RPAREN expr LPAREN @5 subSpace .

    $default  reduce using rule 44 (ifPart)


state 169

   11 expr: expr . PLUS expr
   12     | expr . MINUS expr
   13     | expr . MULT expr
   14     | expr . DIVIDE expr
   15     | expr . MODULUS expr
   27 defineFor: FOR RPAREN paramList @1 SEMICOLON expr . SEMICOLON iteration LPAREN subSpace

    MINUS      shift, and go to state 95
    PLUS       shift, and go to state 96
    MODULUS    shift, and go to state 97
    DIVIDE     shift, and go to state 98
    MULT       shift, and go to state 99
    SEMICOLON  shift, and go to state 177


state 170

  115 defineWhile: WHILE RPAREN expr LPAREN @11 subSpace .

    $default  reduce using rule 115 (defineWhile)


state 171

   97 switchSpace: RBRACE . switchStats LBRACE

    ENDL     shift, and go to state 2
    CASE     shift, and go to state 178
    DEFAULT  shift, and go to state 179

    ENDL      [reduce using rule 101 (switchStat)]
    CASE      [reduce using rule 101 (switchStat)]
    DEFAULT   [reduce using rule 101 (switchStat)]
    $default  reduce using rule 101 (switchStat)

    endls        go to state 180
    switchStats  go to state 181
    switchStat   go to state 182


state 172

    1 endls: endls . ENDL
   98 switchSpace: endls . switchSpace

    ENDL    shift, and go to state 155
    RBRACE  shift, and go to state 171

    endls        go to state 172
    switchSpace  go to state 183


state 173

   96 defineSwitch: SWITCH RPAREN expr LPAREN @8 switchSpace .

    $default  reduce using rule 96 (defineSwitch)


state 174

   48 elseIfPart: ELSE IF RPAREN expr LPAREN . @6 subSpace

    $default  reduce using rule 47 (@6)

    @6  go to state 184


state 175

   57 initOperatorContext: defineType operator defineType ASSIGN . name endls

    NAME  shift, and go to state 1

    name  go to state 185


state 176

   34 funcHeaderE: RPAREN @4 paramList LPAREN COLON defineType .
   35 funcType: defineType . COLON RPAREN typeList LPAREN

    COLON  shift, and go to state 47

    $default  reduce using rule 34 (funcHeaderE)


state 177

   27 defineFor: FOR RPAREN paramList @1 SEMICOLON expr SEMICOLON . iteration LPAREN subSpace

    NAME  shift, and go to state 1

    name        go to state 62
    defineIden  go to state 35
    idenFunc    go to state 67
    assignment  go to state 39
    iteration   go to state 186


state 178

  104 switchStat: CASE . RPAREN expr LPAREN @9 subSpace

    RPAREN  shift, and go to state 187


state 179

  106 switchStat: DEFAULT . @10 subSpace

    $default  reduce using rule 105 (@10)

    @10  go to state 188


state 180

    1 endls: endls . ENDL
  102 switchStat: endls .

    ENDL  shift, and go to state 20

    ENDL      [reduce using rule 102 (switchStat)]
    $default  reduce using rule 102 (switchStat)


state 181

   97 switchSpace: RBRACE switchStats . LBRACE
   99 switchStats: switchStats . switchStat

    ENDL     shift, and go to state 2
    LBRACE   shift, and go to state 189
    CASE     shift, and go to state 178
    DEFAULT  shift, and go to state 179

    ENDL     [reduce using rule 101 (switchStat)]
    LBRACE   [reduce using rule 101 (switchStat)]
    CASE     [reduce using rule 101 (switchStat)]
    DEFAULT  [reduce using rule 101 (switchStat)]

    endls       go to state 180
    switchStat  go to state 190


state 182

  100 switchStats: switchStat .

    $default  reduce using rule 100 (switchStats)


state 183

   98 switchSpace: endls switchSpace .

    $default  reduce using rule 98 (switchSpace)


state 184

   48 elseIfPart: ELSE IF RPAREN expr LPAREN @6 . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 130

    endls     go to state 131
    subSpace  go to state 191


state 185

   57 initOperatorContext: defineType operator defineType ASSIGN name . endls

    ENDL  shift, and go to state 2

    endls  go to state 192


state 186

   27 defineFor: FOR RPAREN paramList @1 SEMICOLON expr SEMICOLON iteration . LPAREN subSpace

    LPAREN  shift, and go to state 193


state 187

  104 switchStat: CASE RPAREN . expr LPAREN @9 subSpace

    NAME           shift, and go to state 1
    INT            shift, and go to state 56
    NUMBER         shift, and go to state 57
    STRING         shift, and go to state 58
    VALUE_BOOLEAN  shift, and go to state 59
    VALUE_VOID     shift, and go to state 60
    RPAREN         shift, and go to state 61

    name         go to state 62
    expr         go to state 194
    funcExpr     go to state 64
    funcHeaderE  go to state 65
    defineIden   go to state 66
    idenFunc     go to state 67


state 188

  106 switchStat: DEFAULT @10 . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 130

    endls     go to state 131
    subSpace  go to state 195


state 189

   97 switchSpace: RBRACE switchStats LBRACE .

    $default  reduce using rule 97 (switchSpace)


state 190

   99 switchStats: switchStats switchStat .

    $default  reduce using rule 99 (switchStats)


state 191

   48 elseIfPart: ELSE IF RPAREN expr LPAREN @6 subSpace .

    $default  reduce using rule 48 (elseIfPart)


state 192

    1 endls: endls . ENDL
   57 initOperatorContext: defineType operator defineType ASSIGN name endls .

    ENDL  shift, and go to state 20

    ENDL      [reduce using rule 57 (initOperatorContext)]
    $default  reduce using rule 57 (initOperatorContext)


state 193

   27 defineFor: FOR RPAREN paramList @1 SEMICOLON expr SEMICOLON iteration LPAREN . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 130

    endls     go to state 131
    subSpace  go to state 196


state 194

   11 expr: expr . PLUS expr
   12     | expr . MINUS expr
   13     | expr . MULT expr
   14     | expr . DIVIDE expr
   15     | expr . MODULUS expr
  104 switchStat: CASE RPAREN expr . LPAREN @9 subSpace

    MINUS    shift, and go to state 95
    PLUS     shift, and go to state 96
    MODULUS  shift, and go to state 97
    DIVIDE   shift, and go to state 98
    MULT     shift, and go to state 99
    LPAREN   shift, and go to state 197


state 195

  106 switchStat: DEFAULT @10 subSpace .

    $default  reduce using rule 106 (switchStat)


state 196

   27 defineFor: FOR RPAREN paramList @1 SEMICOLON expr SEMICOLON iteration LPAREN subSpace .

    $default  reduce using rule 27 (defineFor)


state 197

  104 switchStat: CASE RPAREN expr LPAREN . @9 subSpace

    $default  reduce using rule 103 (@9)

    @9  go to state 198


state 198

  104 switchStat: CASE RPAREN expr LPAREN @9 . subSpace

    ENDL    shift, and go to state 2
    RBRACE  shift, and go to state 130

    endls     go to state 131
    subSpace  go to state 199


state 199

  104 switchStat: CASE RPAREN expr LPAREN @9 subSpace .

    $default  reduce using rule 104 (switchStat)
